Public Client
A function to create a Public Client
A Public Client is an interface to "public" JSON-RPC API methods such as retrieving block numbers, transactions, reading from smart contracts, etc through Public Actions.

The createPublicClient function sets up a Public Client with a given Transport configured for a Chain.

Import

import { createPublicClient } from 'viem'
Usage
Initialize a Client with your desired Chain (e.g. mainnet) and Transport (e.g. http).


import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'
 
const publicClient = createPublicClient({ 
  chain: mainnet,
  transport: http()
})
Then you can consume Public Actions:


const blockNumber = await publicClient.getBlockNumber() 
Optimization
The Public Client also supports eth_call Aggregation for improved performance.

eth_call Aggregation (via Multicall)
The Public Client supports the aggregation of eth_call requests into a single multicall (aggregate3) request.

This means for every Action that utilizes an eth_call request (ie. readContract), the Public Client will batch the requests (over a timed period) and send it to the RPC Provider in a single multicall request. This can dramatically improve network performance, and decrease the amount of Compute Units (CU) used by RPC Providers like Alchemy, Infura, etc.

The Public Client schedules the aggregation of eth_call requests over a given time period. By default, it executes the batch request at the end of the current JavaScript message queue (a zero delay), however, consumers can specify a custom wait period (in ms).

You can enable eth_call aggregation by setting the batch.multicall flag to true:


const publicClient = createPublicClient({
  batch: {
    multicall: true, 
  },
  chain: mainnet,
  transport: http(),
})
You can also customize the multicall options.

Now, when you start to utilize readContract Actions, the Public Client will batch and send over those requests at the end of the message queue (or custom time period) in a single eth_call multicall request:

example.ts
client.ts
abi.ts

import { getContract } from 'viem'
import { abi } from './abi'
import { publicClient } from './client'
 
const contract = getContract({ address, abi, client: publicClient })
 
// The below will send a single request to the RPC Provider.
const [name, totalSupply, symbol, balance] = await Promise.all([
  contract.read.name(),
  contract.read.totalSupply(),
  contract.read.symbol(),
  contract.read.balanceOf([address]),
])
Read more on Contract Instances.

Parameters
transport
Type: Transport
The Transport of the Public Client.


const publicClient = createPublicClient({
  chain: mainnet,
  transport: http(), 
})
chain (optional)
Type: Chain
The Chain of the Public Client.


const publicClient = createPublicClient({
  chain: mainnet, 
  transport: http(),
})
batch (optional)
Flags for batch settings.

batch.multicall (optional)
Type: boolean | MulticallBatchOptions
Default: false
Toggle to enable eth_call multicall aggregation.


const publicClient = createPublicClient({
  batch: {
    multicall: true, 
  },
  chain: mainnet,
  transport: http(),
})
batch.multicall.batchSize (optional)
Type: number
Default: 1_024
The maximum size (in bytes) for each multicall (aggregate3) calldata chunk.

Note: Some RPC Providers limit the amount of calldata that can be sent in a single request. It is best to check with your RPC Provider to see if there are any calldata size limits to eth_call requests.


const publicClient = createPublicClient({
  batch: {
    multicall: {
      batchSize: 512, 
    },
  },
  chain: mainnet,
  transport: http(),
})
batch.multicall.deployless (optional)
Type: boolean
Default: false
Enable deployless multicall.


const publicClient = createPublicClient({
  batch: {
    multicall: {
      deployless: true, 
    },
  },
  chain: mainnet,
  transport: http(),
})
batch.multicall.wait (optional)
Type: number
Default: 0 (zero delay)
The maximum number of milliseconds to wait before sending a batch.


const publicClient = createPublicClient({
  batch: {
    multicall: {
      wait: 16, 
    },
  },
  chain: mainnet,
  transport: http(),
})
cacheTime (optional)
Type: number
Default: client.pollingInterval
Time (in ms) that cached data will remain in memory.


const publicClient = createPublicClient({
  cacheTime: 10_000, 
  chain: mainnet,
  transport: http(),
})
ccipRead (optional)
Type: (parameters: CcipRequestParameters) => Promise<CcipRequestReturnType> | false
Default: true
CCIP Read configuration.

CCIP Read is enabled by default, but if set to false, the client will not support offchain CCIP lookups.


const publicClient = createPublicClient({
  ccipRead: false, 
  chain: mainnet,
  transport: http(),
})
ccipRead.request (optional)
Type: (parameters: CcipRequestParameters) => Promise<CcipRequestReturnType>
A function that will be called to make the offchain CCIP lookup request.


const publicClient = createPublicClient({
  ccipRead: { 
    async request({ data, sender, urls }) { 
      // ... 
    } 
  }, 
  chain: mainnet,
  transport: http(),
})
experimental_blockTag (optional)
Type: BlockTag
Default: 'latest'
The default block tag to use for Actions.

This will be used as the default block tag for the following Actions:

call
estimateGas
getBalance
getBlock
simulateBlocks
waitForTransactionReceipt
watchBlocks
If the chain supports a pre-confirmation mechanism (set via chain.experimental_preconfirmationTime), the default block tag will be 'pending'.


const publicClient = createPublicClient({
  experimental_blockTag: 'pending', 
  chain: mainnet,
  transport: http(),
})
key (optional)
Type: string
Default: "public"
A key for the Client.


const publicClient = createPublicClient({
  chain: mainnet,
  key: 'public', 
  transport: http(),
})
name (optional)
Type: string
Default: "Public Client"
A name for the Client.


const publicClient = createPublicClient({
  chain: mainnet,
  name: 'Public Client', 
  transport: http(),
})
pollingInterval (optional)
Type: number
Default: 4_000
Frequency (in ms) for polling enabled Actions.


const publicClient = createPublicClient({
  chain: mainnet,
  pollingInterval: 10_000, 
  transport: http(),
})
rpcSchema (optional)
Type: RpcSchema
Default: PublicRpcSchema
Typed JSON-RPC schema for the client.


import { rpcSchema } from 'viem'
 
type CustomRpcSchema = [{ 
  Method: 'eth_wagmi', 
  Parameters: [string] 
  ReturnType: string
}] 
 
const publicClient = createPublicClient({
  chain: mainnet,
  rpcSchema: rpcSchema<CustomRpcSchema>(), 
  transport: http(),
})
 
const result = await publicClient.request({ 
  method: 'eth_wa
 // [!code focus] 
  params: ['hello'], 
}) 
Live Example
Check out the usage of createPublicClient in the live Public Client Example below.






Bundler Client
A function to create a Bundler Client.
A Bundler Client is an interface to interact with ERC-4337 Bundlers and provides the ability to send and retrieve User Operations through Bundler Actions.

Import

import { createBundlerClient } from 'viem/account-abstraction'
Usage

import { createPublicClient, http } from 'viem'
import { createBundlerClient } from 'viem/account-abstraction'
import { mainnet } from 'viem/chains'
 
const client = createPublicClient({
  chain: mainnet,
  transport: http()
})
 
const bundlerClient = createBundlerClient({ 
  client, 
  transport: http('https://public.pimlico.io/v2/1/rpc') 
}) 
The Bundler URL above is a public endpoint. Please do not use it in production as you will likely be rate-limited. Consider using Pimlico's Bundler, Biconomy's Bundler, or another Bundler service.

Parameters
account (optional)
Type: SmartAccount
The Smart Account to use for the Bundler Client. This will be used for Actions that require an account as an argument.


import { toCoinbaseSmartAccount } from 'viem/account-abstraction'
import { privateKeyToAccount } from 'viem/accounts'
 
const owner = privateKeyToAccount('0x...')
 
const account = await toCoinbaseSmartAccount({ 
  client, 
  owners: [owner], 
  version: '1.1', 
}) 
 
const bundlerClient = createBundlerClient({
  account, 
  client,
  transport: http('https://public.pimlico.io/v2/1/rpc'),
})
chain (optional)
Type: Chain
The Chain of the Bundler Client.


import { mainnet } from 'viem/chains' 
 
const bundlerClient = createBundlerClient({
  chain: mainnet, 
  transport: http('https://public.pimlico.io/v2/1/rpc')
})
client (optional)
Type: Client
The Client (pointing to execution RPC) of the Bundler Client.


import { createPublicClient, http } from 'viem' 
import { mainnet } from 'viem/chains'
 
const client = createPublicClient({ 
  chain: mainnet, 
  transport: http() 
}) 
 
const bundlerClient = createBundlerClient({
  client, 
  transport: http('https://public.pimlico.io/v2/1/rpc')
})
key (optional)
Type: string
Default: "bundler"
A key for the Client.


const client = createBundlerClient({
  key: 'foo', 
  transport: http('https://public.pimlico.io/v2/1/rpc')
})
name (optional)
Type: string
Default: "Bundler Client"
A name for the Client.


const client = createBundlerClient({
  name: 'Foo Bundler Client', 
  transport: http('https://public.pimlico.io/v2/1/rpc')
})
paymaster (optional)
Type: true | PaymasterClient | { getPaymasterData: typeof getPaymasterData, getPaymasterStubData: typeof getPaymasterStubData }
Sets Paymaster configuration for the Bundler Client to be utilized on User Operations.

If paymaster: PaymasterClient, it will use the provided Paymaster Client for User Operation sponsorship.
If paymaster: true, it will be assumed that the Bundler Client also supports Paymaster RPC methods (e.g. pm_getPaymasterData), and use them for User Operation sponsorship.
If custom functions are provided to paymaster, it will use them for User Operation sponsorship.
Using a Paymaster Client

const paymasterClient = createPaymasterClient({ 
  transport: http('https://public.pimlico.io/v2/11155111/rpc') 
}) 
 
const bundlerClient = createBundlerClient({
  chain: mainnet,
  paymaster: paymasterClient, 
  transport: http('https://public.pimlico.io/v2/1/rpc'),
})
Using the Bundler Client as Paymaster

const bundlerClient = createBundlerClient({
  chain: mainnet,
  paymaster: true, 
  transport: http('https://public.pimlico.io/v2/1/rpc'),
})
Using Custom Paymaster Functions
See the properties below for more information on how to use custom Paymaster functions.

paymaster.getPaymasterData (optional)
Type: (userOperation: UserOperation) => Promise<GetPaymasterDataReturnType>
Retrieves paymaster-related User Operation properties to be used for sending the User Operation.

Read more


const bundlerClient = createBundlerClient({
  chain: mainnet,
  paymaster: { 
    async getPaymasterData(userOperation) { 
      // Retrieve paymaster properties for the User Operation. 
      return { 
        paymaster: '0x...', 
        paymasterData: '0x...', 
        paymasterVerificationGasLimit: 69420n, 
        paymasterPostOpGasLimit: 69420n, 
      } 
    } 
  } 
  transport: http('https://public.pimlico.io/v2/1/rpc'),
})
paymaster.getPaymasterStubData (optional)
Type: (userOperation: UserOperation) => Promise<GetPaymasterStubDataReturnType>
Retrieves paymaster-related User Operation properties to be used for gas estimation.

Read more


const bundlerClient = createBundlerClient({
  chain: mainnet,
  paymaster: { 
    async getPaymasterStubData(userOperation) { 
      // Retrieve paymaster properties for the User Operation. 
      return { 
        paymaster: '0x...', 
        paymasterData: '0x...', 
        paymasterVerificationGasLimit: 69420n, 
        paymasterPostOpGasLimit: 69420n, 
      } 
    } 
    async getPaymasterData(userOperation) { /* ... */ }
  } 
  transport: http('https://public.pimlico.io/v2/1/rpc'),
})
paymasterContext (optional)
Type: unknown
Paymaster specific fields.


const paymasterClient = createPaymasterClient({
  transport: http('https://public.pimlico.io/v2/1/rpc')
})
 
const bundlerClient = createBundlerClient({
  chain: mainnet,
  paymaster: paymasterClient,
  paymasterContext: { 
    policyId: 'abc123'
  }, 
  transport: http('https://public.pimlico.io/v2/1/rpc'),
})
pollingInterval (optional)
Type: number
Default: 4_000
Frequency (in ms) for polling enabled Actions.


const client = createBundlerClient({
  pollingInterval: 10_000, 
  transport: http('https://public.pimlico.io/v2/1/rpc')
})
rpcSchema (optional)
Type: RpcSchema
Default: BundlerRpcSchema
Typed JSON-RPC schema for the client.


import { rpcSchema } from 'viem'
 
type CustomRpcSchema = [{ 
  Method: 'eth_wagmi', 
  Parameters: [string] 
  ReturnType: string
}] 
 
const client = createBundlerClient({
  rpcSchema: rpcSchema<CustomRpcSchema>(), 
  transport: http('https://public.pimlico.io/v2/1/rpc')
})
 
const result = await client.request({ 
  method: 'eth_wa
 // [!code focus] 
 
  params: ['hello'], 
}) 
transport
Type: Transport
The Transport of the Bundler Client.


const bundlerClient = createBundlerClient({
  chain: mainnet,
  transport: http('https://public.pimlico.io/v2/1/rpc'), 
})
userOperation (optional)
Configuration for User Operations.

userOperation.estimateFeesPerGas
Type: ({ account: Account, bundlerClient: Client, userOperation: UserOperationRequest }) => Promise<{ maxFeePerGas: bigint, maxPriorityFeePerGas: bigint }>
Prepares fee properties for the User Operation request.


const bundlerClient = createBundlerClient({
  chain: mainnet,
  transport: http('https://public.pimlico.io/v2/1/rpc'),
  userOperation: { 
    async estimateFeesPerGas({ account, bundlerClient, userOperation }) { 
      // Estimate fees per gas for the User Operation. 
      return { 
        maxFeePerGas: /* ... */, 
        maxPriorityFeePerGas: /* ... */, 
      } 
    } 
  } 
})





