Get Started with Embedded Wallets

Copy page

In this guide we’ll see a quick example of using the Biconomy MEE stack with an Embedded wallet provider.
For this guide, we’ll use Privy. Use the sidebar on the left and scroll down to Integrations section to find tutorials for integration with other embedded wallet providers.
Important
To keep things short, this guide will show you a simple example of single-chain orchestration with cross-chain gas. However, the Biconomy MEE stack supports multi-chain orchestration cases. If you’re looking to build a multi-chain DeFi strategy - read this guide.
This tutorial walks you through how to use Privy (for authentication and embedded wallets) together with Biconomy MEE (for gasless, cross-chain transactions using EIP-7702). We will integrate these in a Vite + React + Wagmi application.
​
Project Setup
Create your project using Vite:

Copy

Ask AI
bun create vite biconomy-mee-embedded-example --template react-ts
cd biconomy-mee-embedded-example
Add the following to your package.json:

Copy

Ask AI
"dependencies": {
  "@biconomy/abstractjs": "^1.0.17",
  "@privy-io/react-auth": "^2.14.2",
  "@privy-io/wagmi": "^1.0.4",
  "@tanstack/react-query": "^5.80.7",
  "react": "^19.1.0",
  "react-dom": "^19.1.0",
  "viem": "^2.31.3",
  "wagmi": "^2.15.6"
}
Install dependencies:

Copy

Ask AI
bun install
Set up your main.tsx:

Copy

Ask AI
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App.tsx';
import './index.css';

import { PrivyProvider } from '@privy-io/react-auth';
import { WagmiProvider } from 'wagmi';
import { wagmiConfig } from './wagmi.ts';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';

const appId = 'your-privy-app-id';
const queryClient = new QueryClient();

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <PrivyProvider
      appId={appId}
      config={{
        embeddedWallets: {
          ethereum: {
            createOnLogin: 'all-users',
          },
        },
      }}
    >
      <QueryClientProvider client={queryClient}>
        <WagmiProvider config={wagmiConfig}>
          <App />
        </WagmiProvider>
      </QueryClientProvider>
    </PrivyProvider>
  </React.StrictMode>
);
In wagmi.ts:

Copy

Ask AI
import { createConfig } from '@privy-io/wagmi';
import { http } from 'wagmi';
import { baseSepolia, optimismSepolia } from 'viem/chains';

export const wagmiConfig = createConfig({
  chains: [optimismSepolia, baseSepolia],
  transports: {
    [optimismSepolia.id]: http(),
    [baseSepolia.id]: http(),
  },
});
​
Get the Embedded Wallet Instance
After logging in the user with Privy, you can find the embedded wallet as follows:

Copy

Ask AI
const wallet = wallets.find(wallet => wallet.walletClientType === 'privy');
​
Authorizing with EIP-7702
To install the Biconomy Nexus 1.2.0 smart account on the address of your Privy embedded wallet EOA, you need to sign the following authorization. Note: This is using the signAuthorization method exposed by the useSignAuthorization Privy hook.

Copy

Ask AI
const authorization = await signAuthorization({
  contractAddress: NEXUS_V120,
  chainId: baseSepolia.id, // or 0 for universal
  nonce: 0,
});
​
Execute a Cross-Chain Gas Abstracted Transaction
After signing, you can submit a transaction through Biconomy MEE Relayers. Notice few things for this transaction:
Gas is paid with USDC
Gas is paid on a different chain than the instruction being executed
The amount arg in the ERC-20 transfer call is not fixed to a value, but uses runtimeERC20BalanceOf which will inject the full amount of USDC available
This demonstrates few key points of MEE:
Gas abstraction / gas sponsorship
Multi-chain execution/orchestration
Runtime parameter injection enabling multi-transaction composability

Copy

Ask AI
const orchestrator = await toMultichainNexusAccount({
  chainConfigurations: [
    {
      chain: optimismSepolia,
      transport: http(),
      version: getMEEVersion(MEEVersion.V2_1_0)
    },
    {
      chain: baseSepolia,
      transport: http(),
      version: getMEEVersion(MEEVersion.V2_1_0)
    }
  ],
  signer: await wallet.getEthereumProvider(),
  accountAddress: wallet.address as Address,
});

const meeClient = await createMeeClient({ account: orchestrator });

const sendUSDCBase = await orchestrator.buildComposable({
  type: 'default',
  data: {
    abi: erc20Abi,
    chainId: baseSepolia.id,
    to: usdcAddresses[baseSepolia.id],
    functionName: 'transfer',
    args: [
      wallet.address,
      runtimeERC20BalanceOf({
        tokenAddress: usdcAddresses[baseSepolia.id],
        targetAddress: orchestrator.addressOn(baseSepolia.id, true),
        constraints: [greaterThanOrEqualTo(1n)],
      }),
    ],
  },
});

const quote = await meeClient.getQuote({
  instructions: [sendUSDCBase],
  authorization,
  delegate: true,

  // Paying for gas with USDC on Optimism, while
  // executing a transaction on Base!
  feeToken: {
    address: usdcAddresses[optimismSepolia.id],
    chainId: optimismSepolia.id,
  },
});

const { hash } = await meeClient.executeQuote({ quote });
You can then link the user to MEE Scan to track:

Copy

Ask AI
const link = getMeeScanLink(hash);
​
Storing the Authorization
If you’ve used the chainId === 0 for your authorization you can store it (e.g. in localStorage or DB) and replay it for other chains in the future. This gives your users an even more seamless UX.






# Get Started with External Wallets

This quickstart shows how to use **Biconomy MEE's Fusion execution mode** to batch-send ERC-20 tokens (USDC) on a **single chain (Base Sepolia)** using a regular **EOA wallet (e.g. MetaMask)**. It demonstrates how an externally owned account can:

* Batch transfer tokens to multiple recipients
* Pay for gas using **ERC-20 tokens** (not ETH)
* Do this all with a **single signature**
* Without using smart wallets or EIP-7702

## Why not EIP-7702?

<AccordionGroup>
  <Accordion title="Wallets don't allow apps to install code">
    While EIP-7702 allowed for smart account code to be set to the EOA address on the *blockchain* level - all major wallets prevent apps from installing their own code onto users EOA addresses. This is done due to the security concerns wallets have around apps installing malicious code.
  </Accordion>

  <Accordion title="Apps access user funds by requesting permissions">
    The approach wallets have taken is to expose a set of permissions to the apps where they can "request" certain tokens, etc... This effort has been spearheaded by MetaMask with their ERC-7715 integration and their DeleGator framework.
  </Accordion>

  <Accordion title="Unclear how the space will develop">
    Other major wallets (Rabby, Trust, Rainbow, Coinbase, Phantom, Uniswap, ...) have not publically stated whether they'll add support for ERC-7715.
  </Accordion>

  <Accordion title="Biconomy offers universal solution">
    The method Biconomy uses is universally compatible with *all* EOA wallets which means you can count on offering these features to everyone.
  </Accordion>
</AccordionGroup>

<Info>
  **Use EIP-7702 with Biconomy + Embedded Wallets**

  Biconomy has full support for EIP-7702. If you wish to take advantage of those features - build by using embedded wallets (e.g. Privy, Dynamic, Turnkey, ...)
</Info>

## How It Works

With Fusion, externally owned accounts (EOAs) can authorize a **Companion Smart Account** (aka "Orchestrator") to pull tokens and execute instructions. The Companion is invisible to users, acting as a passthrough executor that handles batching, permissions, and fee payments.

### Flow Summary

<Steps>
  <Step title="User Authorization">
    The user signs a quote from MEE authorizing their Companion to pull tokens (e.g. USDC)
  </Step>

  <Step title="Batch Execution">
    The Companion executes the batched instructions, using the pulled tokens to:

    * pay for gas
    * send funds to multiple recipients
  </Step>

  <Step title="Seamless Experience">
    From the user's perspective, they signed once and completed the action — no additional UX overhead
  </Step>
</Steps>

## Setup

### 1. Create the project

```bash  theme={null}
bun create vite fusion-single-chain --template react-ts
cd fusion-single-chain
bun install
```

### 2. Install dependencies

```bash  theme={null}
bun add viem wagmi @biconomy/abstractjs
bun add @tanstack/react-query ethers # peer deps for wagmi
```

### 3. Wrap App in providers

Edit `main.tsx` to include `WagmiProvider` and `QueryClientProvider`:

```tsx  theme={null}
// src/main.tsx
import { WagmiProvider } from 'wagmi';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { config } from './wagmi';
import App from './App';

const queryClient = new QueryClient();

ReactDOM.createRoot(document.getElementById('root')!).render(
  <WagmiProvider config={config}>
    <QueryClientProvider client={queryClient}>
      <App />
    </QueryClientProvider>
  </WagmiProvider>
);
```

Then create `wagmi.ts`:

```ts  theme={null}
// src/wagmi.ts
import { baseSepolia } from 'wagmi/chains';
import { createConfig, http } from 'wagmi';

export const config = createConfig({
  chains: [baseSepolia],
  transports: {
    [baseSepolia.id]: http()
  }
});
```

## Key Concepts in App

### Wallet & Companion Initialization

First, we need to connect to the wallet extension. This tutorial uses the `window.ethereum` method, but you should use a more comprehensive solution (e.g. ReOwn AppKit, Web3Modal, RainbowKit, ...)

```ts  theme={null}
const walletClient = createWalletClient({
  chain: baseSepolia,
  transport: custom(window.ethereum)
});

const orchestrator = await toMultichainNexusAccount({
  chainConfigurations: [
    {
      chain: baseSepolia,
      transport: http(),
      version: getMEEVersion(MEEVersion.V2_1_0)
    }
  ],
  signer: walletClient
});

const meeClient = await createMeeClient({ account: orchestrator });
```

### Building Transfer Instructions

You batch multiple `transfer` instructions using `orchestrator.buildComposable(...)`:

```ts  theme={null}
const transfers = await Promise.all(
  recipients.map((recipient) =>
    orchestrator.buildComposable({
      type: 'default',
      data: {
        abi: erc20Abi,
        chainId: baseSepolia.id,
        to: usdcAddress,
        functionName: 'transfer',
        args: [recipient, 1_000_000n] // 1 USDC in 6 decimals
      }
    })
  )
);
```

### Triggering Fusion Execution

Fusion flows require a **trigger** that pulls tokens from the EOA:

```ts  theme={null}
const fusionQuote = await meeClient.getFusionQuote({
  instructions: transfers,
  trigger: {
    chainId: baseSepolia.id,
    tokenAddress: usdcAddress,
    amount: totalAmount // no maxAvailableFunds
  },
  feeToken: {
    address: usdcAddress,
    chainId: baseSepolia.id
  }
});
```

The signature over this quote includes the hash of all instructions and the fee + pull logic. One signature does it all.

### Execute & Monitor

```ts  theme={null}
const { hash } = await meeClient.executeFusionQuote({ fusionQuote });

await meeClient.waitForSupertransactionReceipt({ hash });
const link = getMeeScanLink(hash);
```

***

## Full Example Files

<Tabs>
  <Tab title="App.tsx">
    ```tsx  theme={null}
    import { useState } from 'react';
    import {
      createWalletClient,
      custom,
      erc20Abi,
      http,
      type WalletClient,
      type Hex,
      formatUnits
    } from 'viem';
    import { baseSepolia } from 'viem/chains';
    import {
      createMeeClient,
      toMultichainNexusAccount,
      runtimeERC20BalanceOf,
      greaterThanOrEqualTo,
      getMeeScanLink,
      type MeeClient,
      type MultichainSmartAccount,
      getMEEVersion,
      MEEVersion
    } from '@biconomy/abstractjs';
    import { useReadContract } from 'wagmi';

    export default function App() {
      const [account, setAccount] = useState<string | null>(null);
      const [walletClient, setWalletClient] = useState<WalletClient | null>(null);
      const [meeClient, setMeeClient] = useState<MeeClient | null>(null);
      const [orchestrator, setOrchestrator] = useState<MultichainSmartAccount | null>(null);
      const [status, setStatus] = useState<string | null>(null);
      const [meeScanLink, setMeeScanLink] = useState<string | null>(null);
      const [recipients, setRecipients] = useState<string[]>(['']);

      const usdcAddress = '0x036CbD53842c5426634e7929541eC2318f3dCF7e';

      const { data: balance } = useReadContract({
        abi: erc20Abi,
        address: usdcAddress,
        chainId: baseSepolia.id,
        functionName: 'balanceOf',
        args: account ? [account as Hex] : undefined,
        query: { enabled: !!account }
      });

      const connectAndInit = async () => {
        if (typeof (window as any).ethereum === 'undefined') {
          alert('MetaMask not detected');
          return;
        }

        const wallet = createWalletClient({
          chain: baseSepolia,
          transport: custom((window as any).ethereum)
        });
        setWalletClient(wallet);

        const [address] = await wallet.requestAddresses();
        setAccount(address);

        const multiAccount = await toMultichainNexusAccount({
          chainConfigurations: [
            {
              chain: baseSepolia,
              transport: http(),
              version: getMEEVersion(MEEVersion.V2_1_0)
            }
          ],
          signer: createWalletClient({
            account: address,
            transport: custom((window as any).ethereum)
          })
        });
        setOrchestrator(multiAccount);

        const mee = await createMeeClient({ account: multiAccount });
        setMeeClient(mee);
      };

      const executeTransfers = async () => {
        if (!orchestrator || !meeClient || !account) {
          alert('Account not initialized');
          return;
        }

        try {
          setStatus('Encoding instructions…');

          await walletClient?.addChain({ chain: baseSepolia });
          await walletClient?.switchChain({ id: baseSepolia.id });

          const transfers = await Promise.all(
            recipients
              .filter((r) => r)
              .map((recipient) =>
                orchestrator.buildComposable({
                  type: 'default',
                  data: {
                    abi: erc20Abi,
                    chainId: baseSepolia.id,
                    to: usdcAddress,
                    functionName: 'transfer',
                    args: [recipient as Hex, 1n * 10n ** 6n] // 1 USDC
                  }
                })
              )
          );

          const totalAmount = BigInt(transfers.length) * 1_000_000n;

          setStatus('Requesting quote…');
          const fusionQuote = await meeClient.getFusionQuote({
            instructions: transfers,
            trigger: {
              chainId: baseSepolia.id,
              tokenAddress: usdcAddress,
              amount: totalAmount
            },
            feeToken: {
              address: usdcAddress,
              chainId: baseSepolia.id
            }
          });

          setStatus('Executing quote…');
          const { hash } = await meeClient.executeFusionQuote({ fusionQuote });

          const link = getMeeScanLink(hash);
          setMeeScanLink(link);
          setStatus('Waiting for completion…');

          await meeClient.waitForSupertransactionReceipt({ hash });

          setStatus('Transaction completed!');
        } catch (err: any) {
          console.error(err);
          setStatus(`Error: ${err.message ?? err}`);
        }
      };

      return (
        <main style={{ padding: 40, fontFamily: 'sans-serif', color: 'orangered' }}>
          <h1>Biconomy MEE Quickstart (Base Sepolia)</h1>

          <button
            style={{ padding: '10px 20px', fontSize: '1rem' }}
            onClick={connectAndInit}
            disabled={!!account}
          >
            {account ? `Connected` : 'Connect Wallet'}
          </button>

          {account && (
            <div style={{ marginTop: 20 }}>
              <p><strong>Address:</strong> {account}</p>
              <p>USDC Balance: {balance ? `${formatUnits(balance, 6)} USDC` : '–'}</p>

              <h3>Recipients</h3>
              {recipients.map((recipient, idx) => (
                <input
                  key={idx}
                  type="text"
                  value={recipient}
                  onChange={(e) => {
                    const updated = [...recipients];
                    updated[idx] = e.target.value;
                    setRecipients(updated);
                  }}
                  placeholder="0x..."
                  style={{ display: 'block', margin: '8px 0', padding: '6px', width: '100%' }}
                />
              ))}

              <button onClick={() => setRecipients([...recipients, ''])}>
                Add Recipient
              </button>
            </div>
          )}

          {meeClient && (
            <>
              <p style={{ marginTop: 20 }}>
                <strong>MEE client ready</strong> – you can now orchestrate multichain transactions!
              </p>

              <button
                style={{ padding: '10px 20px', fontSize: '1rem' }}
                onClick={executeTransfers}
              >
                Send 1 USDC to each recipient
              </button>
            </>
          )}

          {status && <p style={{ marginTop: 20 }}>{status}</p>}

          {meeScanLink && (
            <p style={{ marginTop: 10 }}>
              <a href={meeScanLink} target='_blank' rel='noopener noreferrer'>
                View on MEE Scan
              </a>
            </p>
          )}
        </main>
      );
    }
    ```
  </Tab>

  <Tab title="main.tsx">
    ```tsx  theme={null}
    import ReactDOM from 'react-dom/client';
    import { WagmiProvider } from 'wagmi';
    import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
    import { config } from './wagmi';
    import App from './App';

    const queryClient = new QueryClient();

    ReactDOM.createRoot(document.getElementById('root')!).render(
      <WagmiProvider config={config}>
        <QueryClientProvider client={queryClient}>
          <App />
        </QueryClientProvider>
      </WagmiProvider>
    );
    ```
  </Tab>
</Tabs>

<Note>
  Ready to publish this to the official docs or format it as a starter repository!
</Note>




# Get Started with External Wallets

This quickstart shows how to use **Biconomy MEE's Fusion execution mode** to batch-send ERC-20 tokens (USDC) on a **single chain (Base Sepolia)** using a regular **EOA wallet (e.g. MetaMask)**. It demonstrates how an externally owned account can:

* Batch transfer tokens to multiple recipients
* Pay for gas using **ERC-20 tokens** (not ETH)
* Do this all with a **single signature**
* Without using smart wallets or EIP-7702

## Why not EIP-7702?

<AccordionGroup>
  <Accordion title="Wallets don't allow apps to install code">
    While EIP-7702 allowed for smart account code to be set to the EOA address on the *blockchain* level - all major wallets prevent apps from installing their own code onto users EOA addresses. This is done due to the security concerns wallets have around apps installing malicious code.
  </Accordion>

  <Accordion title="Apps access user funds by requesting permissions">
    The approach wallets have taken is to expose a set of permissions to the apps where they can "request" certain tokens, etc... This effort has been spearheaded by MetaMask with their ERC-7715 integration and their DeleGator framework.
  </Accordion>

  <Accordion title="Unclear how the space will develop">
    Other major wallets (Rabby, Trust, Rainbow, Coinbase, Phantom, Uniswap, ...) have not publically stated whether they'll add support for ERC-7715.
  </Accordion>

  <Accordion title="Biconomy offers universal solution">
    The method Biconomy uses is universally compatible with *all* EOA wallets which means you can count on offering these features to everyone.
  </Accordion>
</AccordionGroup>

<Info>
  **Use EIP-7702 with Biconomy + Embedded Wallets**

  Biconomy has full support for EIP-7702. If you wish to take advantage of those features - build by using embedded wallets (e.g. Privy, Dynamic, Turnkey, ...)
</Info>

## How It Works

With Fusion, externally owned accounts (EOAs) can authorize a **Companion Smart Account** (aka "Orchestrator") to pull tokens and execute instructions. The Companion is invisible to users, acting as a passthrough executor that handles batching, permissions, and fee payments.

### Flow Summary

<Steps>
  <Step title="User Authorization">
    The user signs a quote from MEE authorizing their Companion to pull tokens (e.g. USDC)
  </Step>

  <Step title="Batch Execution">
    The Companion executes the batched instructions, using the pulled tokens to:

    * pay for gas
    * send funds to multiple recipients
  </Step>

  <Step title="Seamless Experience">
    From the user's perspective, they signed once and completed the action — no additional UX overhead
  </Step>
</Steps>

## Setup

### 1. Create the project

```bash  theme={null}
bun create vite fusion-single-chain --template react-ts
cd fusion-single-chain
bun install
```

### 2. Install dependencies

```bash  theme={null}
bun add viem wagmi @biconomy/abstractjs
bun add @tanstack/react-query ethers # peer deps for wagmi
```

### 3. Wrap App in providers

Edit `main.tsx` to include `WagmiProvider` and `QueryClientProvider`:

```tsx  theme={null}
// src/main.tsx
import { WagmiProvider } from 'wagmi';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { config } from './wagmi';
import App from './App';

const queryClient = new QueryClient();

ReactDOM.createRoot(document.getElementById('root')!).render(
  <WagmiProvider config={config}>
    <QueryClientProvider client={queryClient}>
      <App />
    </QueryClientProvider>
  </WagmiProvider>
);
```

Then create `wagmi.ts`:

```ts  theme={null}
// src/wagmi.ts
import { baseSepolia } from 'wagmi/chains';
import { createConfig, http } from 'wagmi';

export const config = createConfig({
  chains: [baseSepolia],
  transports: {
    [baseSepolia.id]: http()
  }
});
```

## Key Concepts in App

### Wallet & Companion Initialization

First, we need to connect to the wallet extension. This tutorial uses the `window.ethereum` method, but you should use a more comprehensive solution (e.g. ReOwn AppKit, Web3Modal, RainbowKit, ...)

```ts  theme={null}
const walletClient = createWalletClient({
  chain: baseSepolia,
  transport: custom(window.ethereum)
});

const orchestrator = await toMultichainNexusAccount({
  chainConfigurations: [
    {
      chain: baseSepolia,
      transport: http(),
      version: getMEEVersion(MEEVersion.V2_1_0)
    }
  ],
  signer: walletClient
});

const meeClient = await createMeeClient({ account: orchestrator });
```

### Building Transfer Instructions

You batch multiple `transfer` instructions using `orchestrator.buildComposable(...)`:

```ts  theme={null}
const transfers = await Promise.all(
  recipients.map((recipient) =>
    orchestrator.buildComposable({
      type: 'default',
      data: {
        abi: erc20Abi,
        chainId: baseSepolia.id,
        to: usdcAddress,
        functionName: 'transfer',
        args: [recipient, 1_000_000n] // 1 USDC in 6 decimals
      }
    })
  )
);
```

### Triggering Fusion Execution

Fusion flows require a **trigger** that pulls tokens from the EOA:

```ts  theme={null}
const fusionQuote = await meeClient.getFusionQuote({
  instructions: transfers,
  trigger: {
    chainId: baseSepolia.id,
    tokenAddress: usdcAddress,
    amount: totalAmount // no maxAvailableFunds
  },
  feeToken: {
    address: usdcAddress,
    chainId: baseSepolia.id
  }
});
```

The signature over this quote includes the hash of all instructions and the fee + pull logic. One signature does it all.

### Execute & Monitor

```ts  theme={null}
const { hash } = await meeClient.executeFusionQuote({ fusionQuote });

await meeClient.waitForSupertransactionReceipt({ hash });
const link = getMeeScanLink(hash);
```

***

## Full Example Files

<Tabs>
  <Tab title="App.tsx">
    ```tsx  theme={null}
    import { useState } from 'react';
    import {
      createWalletClient,
      custom,
      erc20Abi,
      http,
      type WalletClient,
      type Hex,
      formatUnits
    } from 'viem';
    import { baseSepolia } from 'viem/chains';
    import {
      createMeeClient,
      toMultichainNexusAccount,
      runtimeERC20BalanceOf,
      greaterThanOrEqualTo,
      getMeeScanLink,
      type MeeClient,
      type MultichainSmartAccount,
      getMEEVersion,
      MEEVersion
    } from '@biconomy/abstractjs';
    import { useReadContract } from 'wagmi';

    export default function App() {
      const [account, setAccount] = useState<string | null>(null);
      const [walletClient, setWalletClient] = useState<WalletClient | null>(null);
      const [meeClient, setMeeClient] = useState<MeeClient | null>(null);
      const [orchestrator, setOrchestrator] = useState<MultichainSmartAccount | null>(null);
      const [status, setStatus] = useState<string | null>(null);
      const [meeScanLink, setMeeScanLink] = useState<string | null>(null);
      const [recipients, setRecipients] = useState<string[]>(['']);

      const usdcAddress = '0x036CbD53842c5426634e7929541eC2318f3dCF7e';

      const { data: balance } = useReadContract({
        abi: erc20Abi,
        address: usdcAddress,
        chainId: baseSepolia.id,
        functionName: 'balanceOf',
        args: account ? [account as Hex] : undefined,
        query: { enabled: !!account }
      });

      const connectAndInit = async () => {
        if (typeof (window as any).ethereum === 'undefined') {
          alert('MetaMask not detected');
          return;
        }

        const wallet = createWalletClient({
          chain: baseSepolia,
          transport: custom((window as any).ethereum)
        });
        setWalletClient(wallet);

        const [address] = await wallet.requestAddresses();
        setAccount(address);

        const multiAccount = await toMultichainNexusAccount({
          chainConfigurations: [
            {
              chain: baseSepolia,
              transport: http(),
              version: getMEEVersion(MEEVersion.V2_1_0)
            }
          ],
          signer: createWalletClient({
            account: address,
            transport: custom((window as any).ethereum)
          })
        });
        setOrchestrator(multiAccount);

        const mee = await createMeeClient({ account: multiAccount });
        setMeeClient(mee);
      };

      const executeTransfers = async () => {
        if (!orchestrator || !meeClient || !account) {
          alert('Account not initialized');
          return;
        }

        try {
          setStatus('Encoding instructions…');

          await walletClient?.addChain({ chain: baseSepolia });
          await walletClient?.switchChain({ id: baseSepolia.id });

          const transfers = await Promise.all(
            recipients
              .filter((r) => r)
              .map((recipient) =>
                orchestrator.buildComposable({
                  type: 'default',
                  data: {
                    abi: erc20Abi,
                    chainId: baseSepolia.id,
                    to: usdcAddress,
                    functionName: 'transfer',
                    args: [recipient as Hex, 1n * 10n ** 6n] // 1 USDC
                  }
                })
              )
          );

          const totalAmount = BigInt(transfers.length) * 1_000_000n;

          setStatus('Requesting quote…');
          const fusionQuote = await meeClient.getFusionQuote({
            instructions: transfers,
            trigger: {
              chainId: baseSepolia.id,
              tokenAddress: usdcAddress,
              amount: totalAmount
            },
            feeToken: {
              address: usdcAddress,
              chainId: baseSepolia.id
            }
          });

          setStatus('Executing quote…');
          const { hash } = await meeClient.executeFusionQuote({ fusionQuote });

          const link = getMeeScanLink(hash);
          setMeeScanLink(link);
          setStatus('Waiting for completion…');

          await meeClient.waitForSupertransactionReceipt({ hash });

          setStatus('Transaction completed!');
        } catch (err: any) {
          console.error(err);
          setStatus(`Error: ${err.message ?? err}`);
        }
      };

      return (
        <main style={{ padding: 40, fontFamily: 'sans-serif', color: 'orangered' }}>
          <h1>Biconomy MEE Quickstart (Base Sepolia)</h1>

          <button
            style={{ padding: '10px 20px', fontSize: '1rem' }}
            onClick={connectAndInit}
            disabled={!!account}
          >
            {account ? `Connected` : 'Connect Wallet'}
          </button>

          {account && (
            <div style={{ marginTop: 20 }}>
              <p><strong>Address:</strong> {account}</p>
              <p>USDC Balance: {balance ? `${formatUnits(balance, 6)} USDC` : '–'}</p>

              <h3>Recipients</h3>
              {recipients.map((recipient, idx) => (
                <input
                  key={idx}
                  type="text"
                  value={recipient}
                  onChange={(e) => {
                    const updated = [...recipients];
                    updated[idx] = e.target.value;
                    setRecipients(updated);
                  }}
                  placeholder="0x..."
                  style={{ display: 'block', margin: '8px 0', padding: '6px', width: '100%' }}
                />
              ))}

              <button onClick={() => setRecipients([...recipients, ''])}>
                Add Recipient
              </button>
            </div>
          )}

          {meeClient && (
            <>
              <p style={{ marginTop: 20 }}>
                <strong>MEE client ready</strong> – you can now orchestrate multichain transactions!
              </p>

              <button
                style={{ padding: '10px 20px', fontSize: '1rem' }}
                onClick={executeTransfers}
              >
                Send 1 USDC to each recipient
              </button>
            </>
          )}

          {status && <p style={{ marginTop: 20 }}>{status}</p>}

          {meeScanLink && (
            <p style={{ marginTop: 10 }}>
              <a href={meeScanLink} target='_blank' rel='noopener noreferrer'>
                View on MEE Scan
              </a>
            </p>
          )}
        </main>
      );
    }
    ```
  </Tab>

  <Tab title="main.tsx">
    ```tsx  theme={null}
    import ReactDOM from 'react-dom/client';
    import { WagmiProvider } from 'wagmi';
    import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
    import { config } from './wagmi';
    import App from './App';

    const queryClient = new QueryClient();

    ReactDOM.createRoot(document.getElementById('root')!).render(
      <WagmiProvider config={config}>
        <QueryClientProvider client={queryClient}>
          <App />
        </QueryClientProvider>
      </WagmiProvider>
    );
    ```
  </Tab>
</Tabs>

<Note>
  Ready to publish this to the official docs or format it as a starter repository!
</Note>





# Conditional Execution

Attach runtime conditions to any composable transaction. Transactions wait until conditions are met before execution - enabling limit orders, price-based triggers, and safe conditional operations.

## Why Use Conditional Execution?

<Warning>
  **Traditional approach**: Execute immediately and hope conditions are met, or build complex smart contracts
</Warning>

<Check>
  **With conditions**: Transactions wait intelligently until requirements are satisfied, then execute automatically
</Check>

### Key Benefits

* **Smart waiting** - Transactions stay PENDING until conditions are met (limit orders, price triggers, etc.)
* **User protection** - Only execute when safe (sufficient balance, healthy positions, etc.)
* **MEV protection** - Check price slippage before swaps execute
* **Gas efficient** - Avoid failed transactions by verifying conditions first
* **Works everywhere** - Compatible with ALL instruction types (transfer, approve, default, etc.)
* **Type-safe** - Full TypeScript support with ABI inference

### Common Use Cases

* **Limit orders** - Wait for price to reach target level before executing
* **Balance-triggered actions** - Execute when funds arrive from bridges or swaps
* **Safety checks** - Verify contract state (not paused) before execution
* **DeFi safeguards** - Ensure healthy positions before borrowing or withdrawing
* **Slippage protection** - Only execute swaps at acceptable prices

## Quick Start

<Steps>
  <Step title="Install the SDK">
    ```bash  theme={null}
    npm install @biconomy/abstractjs@latest viem
    ```
  </Step>

  <Step title="Create a Condition">
    ```typescript  theme={null}
    import { createCondition, ConditionType } from '@biconomy/abstractjs'
    import { erc20Abi, parseUnits } from 'viem'

    // Only execute if balance >= 100 USDC
    const minBalanceCondition = createCondition({
      targetContract: usdcAddress,
      functionAbi: erc20Abi,
      functionName: 'balanceOf',
      args: [userAddress],
      value: parseUnits('100', 6), // 100 USDC (6 decimals)
      type: ConditionType.GTE,
      description: 'Minimum balance: 100 USDC'
    })
    ```
  </Step>

  <Step title="Add to Any Instruction">
    ```typescript  theme={null}
    const instructions = await mcAccount.buildComposable({
      type: 'transfer',
      data: {
        tokenAddress: usdcAddress,
        recipient: recipientAddress,
        amount: transferAmount,
        chainId: base.id,
        conditions: [minBalanceCondition] // ✅ Add here
      }
    })
    ```
  </Step>

  <Step title="Execute">
    ```typescript  theme={null}
    const quote = await meeClient.getQuote({
      instructions,
      feeToken: { chainId: base.id, address: usdcAddress }
    })

    const { hash } = await meeClient.executeQuote({ quote })
    // Transaction waits (PENDING) until condition is met
    // Then executes automatically when balance >= 100 USDC
    ```
  </Step>
</Steps>

## How It Works

Conditions leverage the composability system's STATIC\_CALL mechanism with intelligent waiting:

```
User Submits Transaction with Conditions
    ↓
MEE checks: Condition 1 (STATIC_CALL) → Check constraint
    ↓
   Pass? → Continue
   Fail? → Transaction enters PENDING state
    ↓
MEE periodically rechecks conditions
    ↓
All conditions pass? → Execute main function
    ↓
Success!
```

**Two execution paths:**

1. **Immediate execution** - All conditions pass → Transaction executes immediately
2. **Waiting mode** - Conditions not met → Transaction stays PENDING, MEE periodically rechecks until conditions pass or timeout expires

<Info>
  **Under the hood**: Each condition becomes an InputParam that calls a view/pure function and validates the result against your constraint (GTE, LTE, or EQ). MEE simulates execution periodically, and once simulation succeeds (all conditions pass), the transaction executes onchain.
</Info>

## API Reference

### createCondition

Create a condition that must be satisfied for execution.

```typescript  theme={null}
createCondition({
  targetContract: Address        // Contract to call
  functionAbi: Abi              // ABI containing the function
  functionName: string          // View/pure function name
  args: Array<any>              // Function arguments (type-safe)
  value: bigint                 // Threshold or expected value
  type: ConditionType           // GTE, LTE, or EQ
  description?: string          // Optional description
})
```

### ConditionType

```typescript  theme={null}
enum ConditionType {
  GTE = "gte",  // Greater than or equal to (≥)
  LTE = "lte",  // Less than or equal to (≤)
  EQ = "eq"     // Equal to (=)
}
```

**Examples:**

```typescript  theme={null}
// Balance must be at least 1000 tokens
type: ConditionType.GTE,
value: parseUnits('1000', 18)

// Health factor must not exceed 2.0
type: ConditionType.LTE,
value: parseUnits('2.0', 18)

// Contract must be in ACTIVE state (enum value 2)
type: ConditionType.EQ,
value: 2n
```

## Common Patterns

### Minimum Balance Check

```typescript  theme={null}
const minBalance = parseUnits('50', 6) // 50 USDC

const instructions = await mcAccount.buildComposable({
  type: 'transfer',
  data: {
    tokenAddress: usdcAddress,
    recipient: recipientAddress,
    amount: runtimeERC20BalanceOf({
      targetAddress: senderAddress,
      tokenAddress: usdcAddress
    }),
    chainId: base.id,
    conditions: [
      createCondition({
        targetContract: usdcAddress,
        functionAbi: erc20Abi,
        functionName: 'balanceOf',
        args: [senderAddress],
        value: minBalance,
        type: ConditionType.GTE,
        description: 'Sender must have at least 50 USDC'
      })
    ]
  }
})
```

### Contract Not Paused

```typescript  theme={null}
const pausableAbi = [
  {
    inputs: [],
    name: 'paused',
    outputs: [{ name: '', type: 'bool' }],
    stateMutability: 'view',
    type: 'function'
  }
] as const

const instructions = await mcAccount.buildComposable({
  type: 'default',
  data: {
    to: protocolAddress,
    abi: protocolAbi,
    functionName: 'stake',
    args: [stakeAmount],
    chainId: base.id,
    conditions: [
      createCondition({
        targetContract: protocolAddress,
        functionAbi: pausableAbi,
        functionName: 'paused',
        args: [],
        value: 0n, // False = 0
        type: ConditionType.EQ,
        description: 'Protocol must not be paused'
      })
    ]
  }
})
```

### Multiple Conditions (AND Logic)

All conditions must pass for execution.

```typescript  theme={null}
const instructions = await mcAccount.buildComposable({
  type: 'default',
  data: {
    to: lendingProtocolAddress,
    abi: lendingProtocolAbi,
    functionName: 'borrow',
    args: [borrowParams],
    chainId: base.id,
    conditions: [
      // Condition 1: Sufficient collateral
      createCondition({
        targetContract: collateralTokenAddress,
        functionAbi: erc20Abi,
        functionName: 'balanceOf',
        args: [userAddress],
        value: minCollateralAmount,
        type: ConditionType.GTE
      }),

      // Condition 2: Healthy position
      createCondition({
        targetContract: lendingProtocolAddress,
        functionAbi: lendingProtocolAbi,
        functionName: 'getHealthFactor',
        args: [userAddress],
        value: parseUnits('1.5', 18),
        type: ConditionType.GTE
      }),

      // Condition 3: Protocol not paused
      createCondition({
        targetContract: lendingProtocolAddress,
        functionAbi: lendingProtocolAbi,
        functionName: 'isPaused',
        args: [],
        value: 0n,
        type: ConditionType.EQ
      })
    ]
  }
})
```

<Note>
  **All conditions must pass** - The transaction waits (PENDING) until all conditions are satisfied, or fails if timeout expires.
</Note>

<Accordion title="Limit Orders (Wait for Price)">
  Create a limit order that waits for a price target.

  ```typescript  theme={null}
  const uniswapPoolAbi = [
    {
      inputs: [],
      name: 'slot0',
      outputs: [
        { name: 'sqrtPriceX96', type: 'uint160' },
        { name: 'tick', type: 'int24' },
        // ... other fields
      ],
      stateMutability: 'view',
      type: 'function'
    }
  ] as const

  // Target price: swap only when price >= targetSqrtPriceX96
  const targetPrice = calculateSqrtPriceX96(targetPriceRatio)

  const instructions = await mcAccount.buildComposable({
    type: 'default',
    data: {
      to: uniswapRouterAddress,
      abi: uniswapRouterAbi,
      functionName: 'exactInputSingle',
      args: [swapParams],
      chainId: base.id,
      conditions: [
        createCondition({
          targetContract: poolAddress,
          functionAbi: uniswapPoolAbi,
          functionName: 'slot0',
          args: [],
          value: targetPrice,
          type: ConditionType.GTE, // Wait until price >= target
          description: 'Limit order: execute when price reaches target'
        })
      ]
    }
  })

  // Use getFusionQuote with upperBoundTimestamp to enable waiting
  const fusionQuote = await meeClient.getFusionQuote({
    trigger: { chainId: base.id, tokenAddress: usdcAddress, amount: inputAmount },
    instructions,
    feeToken: { chainId: base.id, address: usdcAddress },
    upperBoundTimestamp: Math.floor(Date.now() / 1000) + 86400 // Wait up to 24 hours
  })

  const { hash } = await meeClient.executeFusionQuote({ fusionQuote })
  // Transaction waits until price reaches target, then executes automatically
  ```
</Accordion>

<Accordion title="MEV Protection">
  Check current price before executing swaps.

  ```typescript  theme={null}
  const uniswapPoolAbi = [
    {
      inputs: [],
      name: 'slot0',
      outputs: [
        { name: 'sqrtPriceX96', type: 'uint160' },
        { name: 'tick', type: 'int24' },
        // ... other fields
      ],
      stateMutability: 'view',
      type: 'function'
    }
  ] as const

  // Calculate acceptable price range
  const currentPrice = await getSpotPrice(poolAddress)
  const maxAcceptablePrice = currentPrice * 101n / 100n // 1% slippage

  const instructions = await mcAccount.buildComposable({
    type: 'default',
    data: {
      to: uniswapRouterAddress,
      abi: uniswapRouterAbi,
      functionName: 'exactInputSingle',
      args: [swapParams],
      chainId: base.id,
      conditions: [
        createCondition({
          targetContract: poolAddress,
          functionAbi: uniswapPoolAbi,
          functionName: 'slot0',
          args: [],
          value: maxAcceptablePrice,
          type: ConditionType.LTE,
          description: 'Price slippage protection'
        })
      ]
    }
  })
  ```
</Accordion>

## Waiting for Conditions

When conditions aren't immediately met, MEE keeps the transaction in PENDING state and periodically checks until conditions pass.

```typescript  theme={null}
const minBalanceRequired = parseUnits('100', 6)

const instructions = await mcAccount.buildComposable({
  type: 'transfer',
  data: {
    tokenAddress: usdcAddress,
    recipient: recipientAddress,
    amount: transferAmount,
    chainId: base.id,
    conditions: [
      createCondition({
        targetContract: usdcAddress,
        functionAbi: erc20Abi,
        functionName: 'balanceOf',
        args: [senderAddress],
        value: minBalanceRequired,
        type: ConditionType.GTE
      })
    ]
  }
})

// Execute with timeout
const fusionQuote = await meeClient.getFusionQuote({
  trigger: { chainId: base.id, tokenAddress: usdcAddress, amount: triggerAmount },
  instructions,
  feeToken: { chainId: base.id, address: usdcAddress },
  upperBoundTimestamp: Math.floor(Date.now() / 1000) + 300 // Wait up to 5 min
})

const { hash } = await meeClient.executeFusionQuote({ fusionQuote })

// Transaction stays PENDING until condition is met
const { transactionStatus } = await meeClient.waitForSupertransactionReceipt({ hash })
```

**Lifecycle:**

1. Submit transaction with conditions
2. **PENDING** - MEE periodically checks conditions
3. **Condition satisfied** - Transaction executes automatically
4. **MINED\_SUCCESS** - Complete

<Info>
  If conditions aren't met within the timeout period, the transaction will eventually FAIL.
</Info>

## Best Practices

### 1. Always Add Descriptions

```typescript  theme={null}
// ✅ Good
createCondition({
  targetContract: usdcAddress,
  functionAbi: erc20Abi,
  functionName: 'balanceOf',
  args: [userAddress],
  value: parseUnits('100', 6),
  type: ConditionType.GTE,
  description: 'User must have at least 100 USDC' // ✅ Clear
})
```

### 2. Use Type-Safe ABIs

```typescript  theme={null}
// ✅ Good - Type-safe
const erc20Abi = [
  {
    inputs: [{ name: 'account', type: 'address' }],
    name: 'balanceOf',
    outputs: [{ name: '', type: 'uint256' }],
    stateMutability: 'view',
    type: 'function'
  }
] as const // ✅ 'as const' for type inference
```

### 3. Limit Number of Conditions

Each condition adds \~5,000-10,000 gas:

* ✅ **1-3 conditions** - Optimal
* ⚠️ **4-5 conditions** - Acceptable if necessary
* ❌ **6+ conditions** - Consider refactoring

### 4. Order by Likelihood of Failure

Place most likely to fail conditions first:

```typescript  theme={null}
conditions: [
  createCondition({ /* paused check - most likely to fail */ }),
  createCondition({ /* balance check */ }),
  createCondition({ /* complex calculation - expensive */ })
]
```

### 5. Handle Decimal Precision

```typescript  theme={null}
// ❌ Wrong - USDC has 6 decimals
value: parseUnits('100', 18)

// ✅ Correct
value: parseUnits('100', 6)
```

### 6. Use Appropriate Constraint Types

```typescript  theme={null}
// ✅ Use EQ for booleans
createCondition({
  functionName: 'paused',
  value: 0n, // false
  type: ConditionType.EQ
})

// ✅ Use GTE for minimum thresholds
createCondition({
  functionName: 'balanceOf',
  value: 1000n,
  type: ConditionType.GTE // At least 1000
})

// ✅ Use LTE for maximum limits
createCondition({
  functionName: 'getHealthFactor',
  value: parseUnits('10', 18),
  type: ConditionType.LTE // At most 10.0
})
```

## Troubleshooting

### Condition Always Fails

**Problem:** Condition consistently reverts.

**Solutions:**

* Verify decimal precision matches token (USDC = 6, WETH = 18)
* Check constraint type is correct (GTE vs LTE vs EQ)
* Test the view function directly to see actual return value
* Ensure target contract address is correct

```typescript  theme={null}
// ❌ Wrong - USDC uses 6 decimals
value: parseUnits('100', 18)

// ✅ Correct
value: parseUnits('100', 6)
```

### Transaction Stuck in PENDING

**Problem:** Transaction never executes.

**Solutions:**

* Check if condition can realistically be met
* Verify correct contract address
* Set reasonable `upperBoundTimestamp`
* Test condition function returns expected value

```typescript  theme={null}
// Add reasonable timeout
upperBoundTimestamp: Math.floor(Date.now() / 1000) + 300 // 5 minutes
```

### Type Errors with ABI

**Problem:** TypeScript complains about function name or args.

**Solutions:**

* Ensure ABI is defined with `as const`
* Check function exists in ABI
* Verify args match function signature

```typescript  theme={null}
// ✅ Correct - ABI with 'as const'
const myAbi = [
  {
    inputs: [{ name: 'account', type: 'address' }],
    name: 'balanceOf',
    outputs: [{ name: '', type: 'uint256' }],
    stateMutability: 'view',
    type: 'function'
  }
] as const // ✅ Important!
```

### Gas Estimation Fails

**Problem:** Transaction simulation fails.

**Solutions:**

* Simplify conditions or reduce count
* Verify view functions can be called successfully
* Check contract addresses are correct
* Ensure function is truly view/pure (no state changes)

## Summary

Conditional execution adds powerful runtime validation to your transactions:

* ✅ Use `createCondition()` to define conditions
* ✅ Add to any `buildComposable` call via `conditions` array
* ✅ All conditions must pass for execution
* ✅ Transactions wait intelligently until conditions are met
* ✅ Perfect for limit orders, price triggers, and safe execution
* ✅ Works with all instruction types

<Tip>
  Start with simple balance checks, then expand to limit orders and complex validations.
</Tip>





# Conditional Execution

Attach runtime conditions to any composable transaction. Transactions wait until conditions are met before execution - enabling limit orders, price-based triggers, and safe conditional operations.

## Why Use Conditional Execution?

<Warning>
  **Traditional approach**: Execute immediately and hope conditions are met, or build complex smart contracts
</Warning>

<Check>
  **With conditions**: Transactions wait intelligently until requirements are satisfied, then execute automatically
</Check>

### Key Benefits

* **Smart waiting** - Transactions stay PENDING until conditions are met (limit orders, price triggers, etc.)
* **User protection** - Only execute when safe (sufficient balance, healthy positions, etc.)
* **MEV protection** - Check price slippage before swaps execute
* **Gas efficient** - Avoid failed transactions by verifying conditions first
* **Works everywhere** - Compatible with ALL instruction types (transfer, approve, default, etc.)
* **Type-safe** - Full TypeScript support with ABI inference

### Common Use Cases

* **Limit orders** - Wait for price to reach target level before executing
* **Balance-triggered actions** - Execute when funds arrive from bridges or swaps
* **Safety checks** - Verify contract state (not paused) before execution
* **DeFi safeguards** - Ensure healthy positions before borrowing or withdrawing
* **Slippage protection** - Only execute swaps at acceptable prices

## Quick Start

<Steps>
  <Step title="Install the SDK">
    ```bash  theme={null}
    npm install @biconomy/abstractjs@latest viem
    ```
  </Step>

  <Step title="Create a Condition">
    ```typescript  theme={null}
    import { createCondition, ConditionType } from '@biconomy/abstractjs'
    import { erc20Abi, parseUnits } from 'viem'

    // Only execute if balance >= 100 USDC
    const minBalanceCondition = createCondition({
      targetContract: usdcAddress,
      functionAbi: erc20Abi,
      functionName: 'balanceOf',
      args: [userAddress],
      value: parseUnits('100', 6), // 100 USDC (6 decimals)
      type: ConditionType.GTE,
      description: 'Minimum balance: 100 USDC'
    })
    ```
  </Step>

  <Step title="Add to Any Instruction">
    ```typescript  theme={null}
    const instructions = await mcAccount.buildComposable({
      type: 'transfer',
      data: {
        tokenAddress: usdcAddress,
        recipient: recipientAddress,
        amount: transferAmount,
        chainId: base.id,
        conditions: [minBalanceCondition] // ✅ Add here
      }
    })
    ```
  </Step>

  <Step title="Execute">
    ```typescript  theme={null}
    const quote = await meeClient.getQuote({
      instructions,
      feeToken: { chainId: base.id, address: usdcAddress }
    })

    const { hash } = await meeClient.executeQuote({ quote })
    // Transaction waits (PENDING) until condition is met
    // Then executes automatically when balance >= 100 USDC
    ```
  </Step>
</Steps>

## How It Works

Conditions leverage the composability system's STATIC\_CALL mechanism with intelligent waiting:

```
User Submits Transaction with Conditions
    ↓
MEE checks: Condition 1 (STATIC_CALL) → Check constraint
    ↓
   Pass? → Continue
   Fail? → Transaction enters PENDING state
    ↓
MEE periodically rechecks conditions
    ↓
All conditions pass? → Execute main function
    ↓
Success!
```

**Two execution paths:**

1. **Immediate execution** - All conditions pass → Transaction executes immediately
2. **Waiting mode** - Conditions not met → Transaction stays PENDING, MEE periodically rechecks until conditions pass or timeout expires

<Info>
  **Under the hood**: Each condition becomes an InputParam that calls a view/pure function and validates the result against your constraint (GTE, LTE, or EQ). MEE simulates execution periodically, and once simulation succeeds (all conditions pass), the transaction executes onchain.
</Info>

## API Reference

### createCondition

Create a condition that must be satisfied for execution.

```typescript  theme={null}
createCondition({
  targetContract: Address        // Contract to call
  functionAbi: Abi              // ABI containing the function
  functionName: string          // View/pure function name
  args: Array<any>              // Function arguments (type-safe)
  value: bigint                 // Threshold or expected value
  type: ConditionType           // GTE, LTE, or EQ
  description?: string          // Optional description
})
```

### ConditionType

```typescript  theme={null}
enum ConditionType {
  GTE = "gte",  // Greater than or equal to (≥)
  LTE = "lte",  // Less than or equal to (≤)
  EQ = "eq"     // Equal to (=)
}
```

**Examples:**

```typescript  theme={null}
// Balance must be at least 1000 tokens
type: ConditionType.GTE,
value: parseUnits('1000', 18)

// Health factor must not exceed 2.0
type: ConditionType.LTE,
value: parseUnits('2.0', 18)

// Contract must be in ACTIVE state (enum value 2)
type: ConditionType.EQ,
value: 2n
```

## Common Patterns

### Minimum Balance Check

```typescript  theme={null}
const minBalance = parseUnits('50', 6) // 50 USDC

const instructions = await mcAccount.buildComposable({
  type: 'transfer',
  data: {
    tokenAddress: usdcAddress,
    recipient: recipientAddress,
    amount: runtimeERC20BalanceOf({
      targetAddress: senderAddress,
      tokenAddress: usdcAddress
    }),
    chainId: base.id,
    conditions: [
      createCondition({
        targetContract: usdcAddress,
        functionAbi: erc20Abi,
        functionName: 'balanceOf',
        args: [senderAddress],
        value: minBalance,
        type: ConditionType.GTE,
        description: 'Sender must have at least 50 USDC'
      })
    ]
  }
})
```

### Contract Not Paused

```typescript  theme={null}
const pausableAbi = [
  {
    inputs: [],
    name: 'paused',
    outputs: [{ name: '', type: 'bool' }],
    stateMutability: 'view',
    type: 'function'
  }
] as const

const instructions = await mcAccount.buildComposable({
  type: 'default',
  data: {
    to: protocolAddress,
    abi: protocolAbi,
    functionName: 'stake',
    args: [stakeAmount],
    chainId: base.id,
    conditions: [
      createCondition({
        targetContract: protocolAddress,
        functionAbi: pausableAbi,
        functionName: 'paused',
        args: [],
        value: 0n, // False = 0
        type: ConditionType.EQ,
        description: 'Protocol must not be paused'
      })
    ]
  }
})
```

### Multiple Conditions (AND Logic)

All conditions must pass for execution.

```typescript  theme={null}
const instructions = await mcAccount.buildComposable({
  type: 'default',
  data: {
    to: lendingProtocolAddress,
    abi: lendingProtocolAbi,
    functionName: 'borrow',
    args: [borrowParams],
    chainId: base.id,
    conditions: [
      // Condition 1: Sufficient collateral
      createCondition({
        targetContract: collateralTokenAddress,
        functionAbi: erc20Abi,
        functionName: 'balanceOf',
        args: [userAddress],
        value: minCollateralAmount,
        type: ConditionType.GTE
      }),

      // Condition 2: Healthy position
      createCondition({
        targetContract: lendingProtocolAddress,
        functionAbi: lendingProtocolAbi,
        functionName: 'getHealthFactor',
        args: [userAddress],
        value: parseUnits('1.5', 18),
        type: ConditionType.GTE
      }),

      // Condition 3: Protocol not paused
      createCondition({
        targetContract: lendingProtocolAddress,
        functionAbi: lendingProtocolAbi,
        functionName: 'isPaused',
        args: [],
        value: 0n,
        type: ConditionType.EQ
      })
    ]
  }
})
```

<Note>
  **All conditions must pass** - The transaction waits (PENDING) until all conditions are satisfied, or fails if timeout expires.
</Note>

<Accordion title="Limit Orders (Wait for Price)">
  Create a limit order that waits for a price target.

  ```typescript  theme={null}
  const uniswapPoolAbi = [
    {
      inputs: [],
      name: 'slot0',
      outputs: [
        { name: 'sqrtPriceX96', type: 'uint160' },
        { name: 'tick', type: 'int24' },
        // ... other fields
      ],
      stateMutability: 'view',
      type: 'function'
    }
  ] as const

  // Target price: swap only when price >= targetSqrtPriceX96
  const targetPrice = calculateSqrtPriceX96(targetPriceRatio)

  const instructions = await mcAccount.buildComposable({
    type: 'default',
    data: {
      to: uniswapRouterAddress,
      abi: uniswapRouterAbi,
      functionName: 'exactInputSingle',
      args: [swapParams],
      chainId: base.id,
      conditions: [
        createCondition({
          targetContract: poolAddress,
          functionAbi: uniswapPoolAbi,
          functionName: 'slot0',
          args: [],
          value: targetPrice,
          type: ConditionType.GTE, // Wait until price >= target
          description: 'Limit order: execute when price reaches target'
        })
      ]
    }
  })

  // Use getFusionQuote with upperBoundTimestamp to enable waiting
  const fusionQuote = await meeClient.getFusionQuote({
    trigger: { chainId: base.id, tokenAddress: usdcAddress, amount: inputAmount },
    instructions,
    feeToken: { chainId: base.id, address: usdcAddress },
    upperBoundTimestamp: Math.floor(Date.now() / 1000) + 86400 // Wait up to 24 hours
  })

  const { hash } = await meeClient.executeFusionQuote({ fusionQuote })
  // Transaction waits until price reaches target, then executes automatically
  ```
</Accordion>

<Accordion title="MEV Protection">
  Check current price before executing swaps.

  ```typescript  theme={null}
  const uniswapPoolAbi = [
    {
      inputs: [],
      name: 'slot0',
      outputs: [
        { name: 'sqrtPriceX96', type: 'uint160' },
        { name: 'tick', type: 'int24' },
        // ... other fields
      ],
      stateMutability: 'view',
      type: 'function'
    }
  ] as const

  // Calculate acceptable price range
  const currentPrice = await getSpotPrice(poolAddress)
  const maxAcceptablePrice = currentPrice * 101n / 100n // 1% slippage

  const instructions = await mcAccount.buildComposable({
    type: 'default',
    data: {
      to: uniswapRouterAddress,
      abi: uniswapRouterAbi,
      functionName: 'exactInputSingle',
      args: [swapParams],
      chainId: base.id,
      conditions: [
        createCondition({
          targetContract: poolAddress,
          functionAbi: uniswapPoolAbi,
          functionName: 'slot0',
          args: [],
          value: maxAcceptablePrice,
          type: ConditionType.LTE,
          description: 'Price slippage protection'
        })
      ]
    }
  })
  ```
</Accordion>

## Waiting for Conditions

When conditions aren't immediately met, MEE keeps the transaction in PENDING state and periodically checks until conditions pass.

```typescript  theme={null}
const minBalanceRequired = parseUnits('100', 6)

const instructions = await mcAccount.buildComposable({
  type: 'transfer',
  data: {
    tokenAddress: usdcAddress,
    recipient: recipientAddress,
    amount: transferAmount,
    chainId: base.id,
    conditions: [
      createCondition({
        targetContract: usdcAddress,
        functionAbi: erc20Abi,
        functionName: 'balanceOf',
        args: [senderAddress],
        value: minBalanceRequired,
        type: ConditionType.GTE
      })
    ]
  }
})

// Execute with timeout
const fusionQuote = await meeClient.getFusionQuote({
  trigger: { chainId: base.id, tokenAddress: usdcAddress, amount: triggerAmount },
  instructions,
  feeToken: { chainId: base.id, address: usdcAddress },
  upperBoundTimestamp: Math.floor(Date.now() / 1000) + 300 // Wait up to 5 min
})

const { hash } = await meeClient.executeFusionQuote({ fusionQuote })

// Transaction stays PENDING until condition is met
const { transactionStatus } = await meeClient.waitForSupertransactionReceipt({ hash })
```

**Lifecycle:**

1. Submit transaction with conditions
2. **PENDING** - MEE periodically checks conditions
3. **Condition satisfied** - Transaction executes automatically
4. **MINED\_SUCCESS** - Complete

<Info>
  If conditions aren't met within the timeout period, the transaction will eventually FAIL.
</Info>

## Best Practices

### 1. Always Add Descriptions

```typescript  theme={null}
// ✅ Good
createCondition({
  targetContract: usdcAddress,
  functionAbi: erc20Abi,
  functionName: 'balanceOf',
  args: [userAddress],
  value: parseUnits('100', 6),
  type: ConditionType.GTE,
  description: 'User must have at least 100 USDC' // ✅ Clear
})
```

### 2. Use Type-Safe ABIs

```typescript  theme={null}
// ✅ Good - Type-safe
const erc20Abi = [
  {
    inputs: [{ name: 'account', type: 'address' }],
    name: 'balanceOf',
    outputs: [{ name: '', type: 'uint256' }],
    stateMutability: 'view',
    type: 'function'
  }
] as const // ✅ 'as const' for type inference
```

### 3. Limit Number of Conditions

Each condition adds \~5,000-10,000 gas:

* ✅ **1-3 conditions** - Optimal
* ⚠️ **4-5 conditions** - Acceptable if necessary
* ❌ **6+ conditions** - Consider refactoring

### 4. Order by Likelihood of Failure

Place most likely to fail conditions first:

```typescript  theme={null}
conditions: [
  createCondition({ /* paused check - most likely to fail */ }),
  createCondition({ /* balance check */ }),
  createCondition({ /* complex calculation - expensive */ })
]
```

### 5. Handle Decimal Precision

```typescript  theme={null}
// ❌ Wrong - USDC has 6 decimals
value: parseUnits('100', 18)

// ✅ Correct
value: parseUnits('100', 6)
```

### 6. Use Appropriate Constraint Types

```typescript  theme={null}
// ✅ Use EQ for booleans
createCondition({
  functionName: 'paused',
  value: 0n, // false
  type: ConditionType.EQ
})

// ✅ Use GTE for minimum thresholds
createCondition({
  functionName: 'balanceOf',
  value: 1000n,
  type: ConditionType.GTE // At least 1000
})

// ✅ Use LTE for maximum limits
createCondition({
  functionName: 'getHealthFactor',
  value: parseUnits('10', 18),
  type: ConditionType.LTE // At most 10.0
})
```

## Troubleshooting

### Condition Always Fails

**Problem:** Condition consistently reverts.

**Solutions:**

* Verify decimal precision matches token (USDC = 6, WETH = 18)
* Check constraint type is correct (GTE vs LTE vs EQ)
* Test the view function directly to see actual return value
* Ensure target contract address is correct

```typescript  theme={null}
// ❌ Wrong - USDC uses 6 decimals
value: parseUnits('100', 18)

// ✅ Correct
value: parseUnits('100', 6)
```

### Transaction Stuck in PENDING

**Problem:** Transaction never executes.

**Solutions:**

* Check if condition can realistically be met
* Verify correct contract address
* Set reasonable `upperBoundTimestamp`
* Test condition function returns expected value

```typescript  theme={null}
// Add reasonable timeout
upperBoundTimestamp: Math.floor(Date.now() / 1000) + 300 // 5 minutes
```

### Type Errors with ABI

**Problem:** TypeScript complains about function name or args.

**Solutions:**

* Ensure ABI is defined with `as const`
* Check function exists in ABI
* Verify args match function signature

```typescript  theme={null}
// ✅ Correct - ABI with 'as const'
const myAbi = [
  {
    inputs: [{ name: 'account', type: 'address' }],
    name: 'balanceOf',
    outputs: [{ name: '', type: 'uint256' }],
    stateMutability: 'view',
    type: 'function'
  }
] as const // ✅ Important!
```

### Gas Estimation Fails

**Problem:** Transaction simulation fails.

**Solutions:**

* Simplify conditions or reduce count
* Verify view functions can be called successfully
* Check contract addresses are correct
* Ensure function is truly view/pure (no state changes)

## Summary

Conditional execution adds powerful runtime validation to your transactions:

* ✅ Use `createCondition()` to define conditions
* ✅ Add to any `buildComposable` call via `conditions` array
* ✅ All conditions must pass for execution
* ✅ Transactions wait intelligently until conditions are met
* ✅ Perfect for limit orders, price triggers, and safe execution
* ✅ Works with all instruction types

<Tip>
  Start with simple balance checks, then expand to limit orders and complex validations.
</Tip>




# Runtime Parameter Injection

Runtime injection gives developers a powerful way to compose transactions when some values — like token amounts — aren't known until execution time. This is a major evolution beyond traditional static batching, where all parameters must be known upfront.

Instead of asking users to guess or estimate how much will arrive after a bridge or swap, AbstractJS lets you define **placeholders** — runtime values — that get resolved dynamically when the transaction is executed.

<img style={{ height: 700 }} src="https://i.imgur.com/5ry2SJ6.jpeg" />

## Why It Matters

Traditional transaction batching is rigid:

* You must hardcode every parameter
* You can't adapt to bridges, swaps, or slippage
* You often over- or under-estimate received amounts

With **runtime injection**, orchestration becomes **adaptive**:

* Use actual token balances at the moment of execution
* Protect users with constraints (e.g. slippage limits)
* Compose flows across chains with fewer assumptions

This eliminates entire classes of user experience problems and makes your apps more reliable.

## Basic Usage

```ts  theme={null}
import { runtimeERC20BalanceOf } from "@biconomy/abstractjs";
import { balanceNotZeroConstraint } from "../utils/balanceNotZero.util";

const swapInstruction = await oNexus.buildComposable({
  type: "default",
  data: {
    chainId: optimism.id,
    to: "0xProtocolAddress",
    abi: protocolAbi,
    functionName: "swap",
    args: [
      runtimeERC20BalanceOf({
        tokenAddress: "0xTokenAddress",
        targetAddress: nexusAddress,
        constraints: [balanceNotZeroConstraint]
      })
    ]
  }
});
```

## Available Runtime Functions

| Function                          | Description                                                    | [Introduced in](/new/versions-and-migrations/mee-versioning) |
| --------------------------------- | -------------------------------------------------------------- | ------------------------------------------------------------ |
| `runtimeERC20BalanceOf`           | Inject the ERC20 balance of a target address at runtime        | MEE v1.0.0                                                   |
| `runtimeNativeBalanceOf`          | Inject the native token balance of a target address at runtime | MEE v2.2.0                                                   |
| `runtimeERC20AllowanceOf`         | Inject the ERC20 token allowance                               | MEE v1.0.0                                                   |
| `runtimeParamViaCustomStaticCall` | Inject any return data (up to 32 bytes in size) at runtime     | MEE v2.2.0                                                   |

⚠️ To access latest functions, please use according MEE Version as described [here](new/getting-started/set-up-abstractjs).

Please refer to the [Supported Chains](contracts-and-audits/supported-chains) page to learn where MEE 2.2.0 is currently supported.

### runtimeERC20BalanceOf

Inject the token balance of an address — most often your orchestrator address — at the time of execution.

```ts  theme={null}
import { balanceNotZeroConstraint } from "../utils/balanceNotZero.util";

const transferAll = await mcNexus.buildComposable({
  type: "default",
  data: {
    to: tokenContract,
    abi: erc20Abi,
    functionName: "transfer",
    args: [
      recipient,
      runtimeERC20BalanceOf({
        tokenAddress: tokenAddress,
        targetAddress: mcNexus.addressOn(chain.id),
        constraints: [balanceNotZeroConstraint]
      })
    ],
    chainId: chain.id
  }
});
```

### runtimeNativeBalanceOf

Inject the native token balance of an address — most often your orchestrator address — at the time of execution.

```ts  theme={null}
import { balanceNotZeroConstraint } from "../utils/balanceNotZero.util";

const transferAll = await mcNexus.buildComposable({
  type: "nativeTokenTransfer",
  data: {
    to: receiverAddress,
    value: runtimeNativeBalanceOf({
            targetAddress: orchestratorAddress
          }),
    chainId: chain.id
  }
});
```

### runtimeERC20AllowanceOf

Inject the ERC20 token allowance between two addresses at the time of execution. This is useful when you need to check or use allowances dynamically.

```ts  theme={null}
const transferAll = await mcNexus.buildComposable({
  type: "default",
  data: {
    to: tokenContract,
    abi: erc20Abi,
    functionName: "transferFrom",
    args: [
      owner,
      recipient,
      runtimeERC20AllowanceOf({
        owner,
        spender: orchestratorAddress,
        tokenAddress: tokenAddress,
        constraints: []
      })
    ],
    chainId: chain.id
  }
});
```

### runtimeParamViaCustomStaticCall

Allows to execute an arbitrary READ (static) call on-chain, and use the return of this call as an input argument.
Return data should be up to 32 bytes: `address`, `bytes32`, `uintXXX` Solidity types are expected.

```ts  theme={null}
const runtimeReceiver = runtimeParamViaCustomStaticCall({
  targetContractAddress,
  functionAbi: targetAbi,
  functionName: "pauser",
  args: []
})

const transferInstruction = await mcNexus.buildComposable({
  type: "nativeTokenTransfer",
  data: {
    to: runtimeReceiver,
    value: amount,
    chainId: chain.id
  }
})

```

## Constraints = Execution Control

Constraints ensure that runtime-injected values meet specific criteria. If constraints are not met, the instruction will not execute.

But even more importantly — they determine **when** instructions will execute. This is key for cross-chain orchestration.

### Transaction Ordering

When a runtime value is used, the orchestration system will **wait until all constraints are satisfied** before executing. This means constraints enforce dependency:

```ts  theme={null}
await oNexus.buildComposable({
  chainId: optimism.id,
  args: [
    runtimeERC20BalanceOf({
      tokenAddress: usdcOnOptimism,
      targetAddress: nexusAddress,
      constraints: [balanceNotZeroConstraint]
    })
  ]
});
```

This instruction won't execute until `nexusAddress` has a non-zero balance of USDC.

In multi-chain orchestration, this is the mechanism that controls execution sequencing.

### Handling Slippage

```ts  theme={null}
constraints: [
  greaterThanOrEqualTo((expectedAmount * 90n) / 100n)
]
```

Use constraints to ensure execution only proceeds under acceptable conditions.

### Safety Nets

Constraints act like assert statements. If the value isn't good — don't execute.

## Cross-Chain Example

```ts  theme={null}
import { balanceNotZeroConstraint } from "../utils/balanceNotZero.util";

// Step 1: Bridge
const bridgeInstruction = await oNexus.buildComposable({
  // bridging config
});

// Step 2: Wait for funds, then swap
const swapInstruction = await oNexus.buildComposable({
  type: "default",
  data: {
    chainId: optimism.id,
    to: "0xSwapProtocol",
    abi: swapAbi,
    functionName: "swapExactTokensForTokens",
    args: [
      runtimeERC20BalanceOf({
        tokenAddress: usdcOnOptimism,
        targetAddress: nexusAddress,
        constraints: [balanceNotZeroConstraint]
      })
    ]
  }
});
```

**How this works:**

1. MEE simulates the swap instruction
2. Simulation fails (no tokens yet)
3. MEE waits and retries
4. Bridge completes
5. Constraints satisfied → transaction proceeds

## Best Practices

<Check>
  Use runtime injection when values are unknown ahead of time
</Check>

<Check>
  Always apply constraints to protect users and define execution rules
</Check>

<Check>
  Use with transfer instructions to sweep remaining balances
</Check>

<Check>
  Design for graceful failure if constraints aren't met
</Check>

## How It Works

AbstractJS builds orchestration callData with **placeholders**. During execution:

1. The smart account receives `executeComposable()`
2. The fallback handler reads blockchain state
3. Runtime values are injected into calldata
4. The final transaction executes with those resolved parameters

This eliminates the need for custom smart contracts or multi-step user flows.

![Composable Fallback Handler](https://i.imgur.com/zESn9BO.png)

## Summary

Runtime injection turns your orchestration flows into **state-aware, auto-sequencing logic** that adapts to bridge results, swap outputs, slippage conditions, and more.

Use it when:

* You're building cross-chain workflows
* You can't predict output values
* You want fewer failures and better UX





# Smart Account V2 → Nexus

> Complete guide to migrate your BiconomyV2 smart accounts to the newer Nexus smart accounts

<Callout type="info">
  This guide explains how to migrate your BiconomySmartAccountV2 smart accounts to the newer Nexus smart accounts. The migration process preserves your account's address, balance, and history while upgrading to Nexus's enhanced architecture.
</Callout>

## Why Migrate?

<CardGroup cols={1}>
  <Card title="Benefits of Migration" icon="arrow-up">
    Migrating from V2 to Nexus smart accounts provides several benefits:

    <Steps>
      <Step title="Enhanced Security">
        Improved security model with modular validators
      </Step>

      <Step title="Better Performance">
        More gas-efficient transaction processing
      </Step>

      <Step title="Expanded Features">
        Access to the newest account abstraction capabilities
      </Step>

      <Step title="Future Compatibility">
        Ensure your smart account remains compatible with the latest AbstractJS SDK
      </Step>
    </Steps>
  </Card>
</CardGroup>

## Migration Process Overview

<CardGroup cols={1}>
  <Card title="Migration Steps" icon="list">
    The migration follows these steps:

    <Steps>
      <Step title="Connect to V2 Account">
        Connect to your existing V2 smart account
      </Step>

      <Step title="Deploy V2 Account">
        If not already deployed. Ensure the account is deployed on-chain
      </Step>

      <Step title="Migrate to Nexus">
        Update implementation and initialize the Nexus account
      </Step>

      <Step title="Verify Migration">
        Test the migrated account with a transaction
      </Step>

      <Step title="Update Your Application">
        Use the latest SDK to interact with the migrated account
      </Step>
    </Steps>
  </Card>
</CardGroup>

## Prerequisites

<Callout type="warning">
  Before starting the migration, ensure you have the following:
</Callout>

<CardGroup cols={1}>
  <Card title="Required Setup" icon="check">
    <Steps>
      <Step title="Update SDK">
        Update to the latest version of the AbstractJS SDK:

        ```bash  theme={null}
        npm install @biconomy/abstractjs
        ```
      </Step>

      <Step title="Prepare Credentials">
        Make sure you have your EOA's private key and the V2 account address
      </Step>
    </Steps>
  </Card>
</CardGroup>

## Step 1: Connect to Your V2 Account

<Card title="V2 Account Connection" icon="plug">
  First, set up the necessary connections to your V2 smart account:

  ```typescript  theme={null}
  import { createWalletClient, http } from "viem";
  import { privateKeyToAccount } from "viem/accounts";
  import { baseSepolia } from "viem/chains";
  import { 
    createSmartAccountClient as createV2Client,
    BiconomySmartAccountV2,
    PaymasterMode
  } from "@biconomy/account";
  import { getMEEVersion, MEEVersion } from "@biconomy/abstractjs";
  import dotenv from "dotenv";

  dotenv.config();

  // Use the version that suits your needs from the list
  // See MEE Versioning
  const version = MEEVersion.V2_1_0;
  const versionConfig = getMEEVersion(version)

  // Define configuration variables
  const config = {
    // Chain and network information
    chain: baseSepolia,
    
    // EOA credentials
    eoaPrivateKey: process.env.EOA_PRIVATE_KEY, // Replace with your private key
    eoaAddress: process.env.EOA_ADDRESS, // Replace with your EOA address
    
    // Biconomy infrastructure URLs
    v2BundlerUrl: process.env.V2_BUNDLER_URL, // Replace with your V2 bundler URL
    nexusBundlerUrl: process.env.NEXUS_BUNDLER_URL, // Replace with your Nexus bundler URL
    
    // API keys
    paymasterApiKey: process.env.PAYMASTER_API_KEY, // Replace with your Paymaster API key
    
    // Nexus contract addresses
    nexusImplementationAddress: versionConfig.implementationAddress,
    nexusBootstrapAddress: versionConfig.bootStrapAddress,
  };

  // Connect to your EOA
  const eoaAccount = privateKeyToAccount(config.eoaPrivateKey as `0x${string}`);
  const client = createWalletClient({
    account: eoaAccount,
    chain: config.chain,
    transport: http(),
  });

  // Connect to your V2 smart account
  const V2Account = await createV2Client({
    signer: client,
    biconomyPaymasterApiKey: config.paymasterApiKey,
    bundlerUrl: config.v2BundlerUrl!,
  });

  // Get V2 account address
  const V2AccountAddress = await V2Account.getAccountAddress();
  console.log("V2 Account Address:", V2AccountAddress);
  ```
</Card>

## Step 2: Check Deployment Status

<Card title="Account Deployment Check" icon="magnifying-glass">
  Check if your V2 account is already deployed, and deploy it if necessary:

  ```typescript  theme={null}
  // Check if account is deployed
  const isDeployed = await V2Account.isAccountDeployed();

  if (!isDeployed) {
    console.log("Account not deployed, deploying now...");
    
    // Deploy the V2 account
    const deploymentResponse = await V2Account.sendTransaction([
      {
        to: V2AccountAddress,
        value: 0n,
        data: "0x",
      },
    ]);

    const { transactionHash } = await deploymentResponse.waitForTxHash();
    console.log("V2 account deployment transaction hash:", transactionHash);
  } else {
    console.log("Account already deployed, proceeding with migration");
  }
  ```
</Card>

## Step 3: Migrate to Nexus

<Card title="Nexus Migration" icon="arrow-right">
  Now perform the migration by updating the implementation to Nexus and initializing the Nexus account:

  ```typescript  theme={null}
  import { 
    encodeFunctionData,
    encodeAbiParameters
  } from "viem";

  async function migrateToNexus(V2Account: BiconomySmartAccountV2) {
    const V2AccountAddress = await V2Account.getAccountAddress();
    
    // Step 1: Update implementation to Nexus
    console.log("Preparing update implementation to Nexus...");
    const updateImplementationCalldata = encodeFunctionData({
      abi: [
        {
          name: "updateImplementation",
          type: "function",
          stateMutability: "nonpayable",
          inputs: [{ type: "address", name: "newImplementation" }],
          outputs: []
        }
      ],
      functionName: "updateImplementation",
      args: [config.nexusImplementationAddress],
    });
    
    const updateImplementationTransaction = {
      to: V2AccountAddress,
      data: updateImplementationCalldata,
    };
    
    // Step 2: Initialize Nexus Account
    console.log("Preparing initialize Nexus account...");
    const ownerAddress = config.eoaAddress;
    
    // Prepare initialization data for the validator
      const initData = encodeFunctionData({
        abi: [
          { 
            name: "initNexusWithDefaultValidator", type: "function",
             stateMutability: "nonpayable", 
             inputs: [
              { type: "bytes", name: "data" }
            ], 
            outputs: [] 
          }
        ],
        functionName: "initNexusWithDefaultValidator",
        args: [ownerAddress as `0x${string}`]
      });
    
    // Encode bootstrap data
    const initDataWithBootstrap = encodeAbiParameters(
      [
        { name: "bootstrap", type: "address" },
        { name: "initData", type: "bytes" },
      ],
      [config.nexusBootstrapAddress, initData]
    );
    
    // Create initializeAccount calldata
    const initializeNexusCalldata = encodeFunctionData({
      abi: [
        {
          name: "initializeAccount",
          type: "function",
          stateMutability: "nonpayable",
          inputs: [{ type: "bytes", name: "data" }],
          outputs: []
        }
      ],
      functionName: "initializeAccount",
      args: [initDataWithBootstrap],
    });
    
    const initializeNexusTransaction = {
      to: V2AccountAddress,
      data: initializeNexusCalldata,
    };
    
    // Send both transactions in a batch
    console.log("Sending migration transaction...");
    const migrateToNexusResponse = await V2Account.sendTransaction(
      [updateImplementationTransaction, initializeNexusTransaction],
      {
        paymasterServiceData: { mode: PaymasterMode.SPONSORED },
      }
    );
    
    const { transactionHash } = await migrateToNexusResponse.waitForTxHash();
    console.log("Migration transaction hash:", transactionHash);
    console.log("Migration completed successfully");
    
    return V2AccountAddress; // Return the address for the next step
  }
  ```
</Card>

## Step 4: Test Your Migrated Account

<Card title="Migration Verification" icon="test">
  After migration, verify that your account works correctly by creating a test transaction:

  ```typescript  theme={null}
  import { createBicoBundlerClient, toNexusAccount, getMEEVersion, MEEVersion } from "@biconomy/abstractjs";
  import { parseEther } from "viem";

  async function testMigratedAccount(accountAddress: string) : Promise<boolean> {
    // Connect to the migrated account using Nexus SDK
    const eoaAccount = privateKeyToAccount(config.eoaPrivateKey as `0x${string}`);
    
    const nexusAccount = createBicoBundlerClient({
      account: await toNexusAccount({
        signer: eoaAccount,
        chainConfiguration: {
          chain: config.chain,
          transport: http(),
          version: getMEEVersion(version)
        },
        // IMPORTANT: Use the same address as your V2 account
        accountAddress: accountAddress as `0x${string}`,
      }),
      transport: http(config.nexusBundlerUrl),
    });
    
    console.log("Testing migrated account...");
    
    // Send a test transaction
    const testHash = await nexusAccount.sendUserOperation({
      calls: [{
        to: config.eoaAddress as `0x${string}`,
        value: parseEther("0.00000001"),
      }],
    });
    
    console.log("Test transaction hash:", testHash);
    
    // Wait for the receipt (optional)
    const receipt = await nexusAccount.waitForUserOperationReceipt({ hash: testHash });
    console.log("Test transaction successful:", receipt.success);
    return receipt.success;
  }
  ```
</Card>

## Step 5: Update Your Application

<Card title="Application Update" icon="code">
  Update your application to use the Nexus SDK for all future interactions:

  ```typescript  theme={null}
  // IMPORTANT: Always use the same address as your V2 account
  const migratedAccountAddress = "YOUR_V2_ACCOUNT_ADDRESS";

  // Use this pattern for all future SDK interactions
  // Use the same version you used to get implementation address to upgrade to
  const nexusAccount = await toNexusAccount({
    signer: eoaAccount,
    chainConfiguration: {
      chain: base,
      transport: http(),
      version: getMEEVersion(version) 
    },
    accountAddress: migratedAccountAddress
  });

  const bundlerClient = createBicoBundlerClient({
    account: nexusAccount,
    transport: http(bundlerUrl)
  });
  ```
</Card>

## Troubleshooting

<CardGroup cols={1}>
  <Card title="Common Issues and Solutions" icon="help">
    If you encounter issues during migration:

    <Tabs>
      <Tab title="Migration Transaction Fails">
        <Steps>
          <Step title="Check Funds">
            Ensure your EOA has sufficient funds for gas
          </Step>

          <Step title="Verify Deployment">
            Verify the V2 account is properly deployed
          </Step>

          <Step title="Check Configuration">
            Check that all environment variables are set correctly
          </Step>
        </Steps>
      </Tab>

      <Tab title="Cannot Access Account After Migration">
        <Steps>
          <Step title="Verify Address">
            Make sure you're using the exact same address as your V2 account in the `accountAddress` parameter
          </Step>

          <Step title="Check Transaction">
            Verify the migration transaction completed successfully
          </Step>
        </Steps>
      </Tab>
    </Tabs>
  </Card>
</CardGroup>

## Next Steps

<Callout type="success">
  After successfully migrating your V2 account to Nexus:
</Callout>

<CardGroup cols={1}>
  <Card title="Post-Migration Actions" icon="check-circle">
    <Steps>
      <Step title="Store Account Address">
        **STORE YOUR ACCOUNT ADDRESS** in your application's persistent storage
      </Step>

      <Step title="Update Application Code">
        **Update your application code** to use the `accountAddress` parameter in all future interactions
      </Step>

      <Step title="Test Thoroughly">
        **Test thoroughly** with real transactions to ensure everything works as expected
      </Step>
    </Steps>
  </Card>
</CardGroup>

<Callout type="info">
  By following this migration guide and properly storing your account address, you've successfully upgraded your V2 account to a Nexus account while preserving its address, balance, and history.
</Callout>




# Smart Account V2 → Nexus

> Complete guide to migrate your BiconomyV2 smart accounts to the newer Nexus smart accounts

<Callout type="info">
  This guide explains how to migrate your BiconomySmartAccountV2 smart accounts to the newer Nexus smart accounts. The migration process preserves your account's address, balance, and history while upgrading to Nexus's enhanced architecture.
</Callout>

## Why Migrate?

<CardGroup cols={1}>
  <Card title="Benefits of Migration" icon="arrow-up">
    Migrating from V2 to Nexus smart accounts provides several benefits:

    <Steps>
      <Step title="Enhanced Security">
        Improved security model with modular validators
      </Step>

      <Step title="Better Performance">
        More gas-efficient transaction processing
      </Step>

      <Step title="Expanded Features">
        Access to the newest account abstraction capabilities
      </Step>

      <Step title="Future Compatibility">
        Ensure your smart account remains compatible with the latest AbstractJS SDK
      </Step>
    </Steps>
  </Card>
</CardGroup>

## Migration Process Overview

<CardGroup cols={1}>
  <Card title="Migration Steps" icon="list">
    The migration follows these steps:

    <Steps>
      <Step title="Connect to V2 Account">
        Connect to your existing V2 smart account
      </Step>

      <Step title="Deploy V2 Account">
        If not already deployed. Ensure the account is deployed on-chain
      </Step>

      <Step title="Migrate to Nexus">
        Update implementation and initialize the Nexus account
      </Step>

      <Step title="Verify Migration">
        Test the migrated account with a transaction
      </Step>

      <Step title="Update Your Application">
        Use the latest SDK to interact with the migrated account
      </Step>
    </Steps>
  </Card>
</CardGroup>

## Prerequisites

<Callout type="warning">
  Before starting the migration, ensure you have the following:
</Callout>

<CardGroup cols={1}>
  <Card title="Required Setup" icon="check">
    <Steps>
      <Step title="Update SDK">
        Update to the latest version of the AbstractJS SDK:

        ```bash  theme={null}
        npm install @biconomy/abstractjs
        ```
      </Step>

      <Step title="Prepare Credentials">
        Make sure you have your EOA's private key and the V2 account address
      </Step>
    </Steps>
  </Card>
</CardGroup>

## Step 1: Connect to Your V2 Account

<Card title="V2 Account Connection" icon="plug">
  First, set up the necessary connections to your V2 smart account:

  ```typescript  theme={null}
  import { createWalletClient, http } from "viem";
  import { privateKeyToAccount } from "viem/accounts";
  import { baseSepolia } from "viem/chains";
  import { 
    createSmartAccountClient as createV2Client,
    BiconomySmartAccountV2,
    PaymasterMode
  } from "@biconomy/account";
  import { getMEEVersion, MEEVersion } from "@biconomy/abstractjs";
  import dotenv from "dotenv";

  dotenv.config();

  // Use the version that suits your needs from the list
  // See MEE Versioning
  const version = MEEVersion.V2_1_0;
  const versionConfig = getMEEVersion(version)

  // Define configuration variables
  const config = {
    // Chain and network information
    chain: baseSepolia,
    
    // EOA credentials
    eoaPrivateKey: process.env.EOA_PRIVATE_KEY, // Replace with your private key
    eoaAddress: process.env.EOA_ADDRESS, // Replace with your EOA address
    
    // Biconomy infrastructure URLs
    v2BundlerUrl: process.env.V2_BUNDLER_URL, // Replace with your V2 bundler URL
    nexusBundlerUrl: process.env.NEXUS_BUNDLER_URL, // Replace with your Nexus bundler URL
    
    // API keys
    paymasterApiKey: process.env.PAYMASTER_API_KEY, // Replace with your Paymaster API key
    
    // Nexus contract addresses
    nexusImplementationAddress: versionConfig.implementationAddress,
    nexusBootstrapAddress: versionConfig.bootStrapAddress,
  };

  // Connect to your EOA
  const eoaAccount = privateKeyToAccount(config.eoaPrivateKey as `0x${string}`);
  const client = createWalletClient({
    account: eoaAccount,
    chain: config.chain,
    transport: http(),
  });

  // Connect to your V2 smart account
  const V2Account = await createV2Client({
    signer: client,
    biconomyPaymasterApiKey: config.paymasterApiKey,
    bundlerUrl: config.v2BundlerUrl!,
  });

  // Get V2 account address
  const V2AccountAddress = await V2Account.getAccountAddress();
  console.log("V2 Account Address:", V2AccountAddress);
  ```
</Card>

## Step 2: Check Deployment Status

<Card title="Account Deployment Check" icon="magnifying-glass">
  Check if your V2 account is already deployed, and deploy it if necessary:

  ```typescript  theme={null}
  // Check if account is deployed
  const isDeployed = await V2Account.isAccountDeployed();

  if (!isDeployed) {
    console.log("Account not deployed, deploying now...");
    
    // Deploy the V2 account
    const deploymentResponse = await V2Account.sendTransaction([
      {
        to: V2AccountAddress,
        value: 0n,
        data: "0x",
      },
    ]);

    const { transactionHash } = await deploymentResponse.waitForTxHash();
    console.log("V2 account deployment transaction hash:", transactionHash);
  } else {
    console.log("Account already deployed, proceeding with migration");
  }
  ```
</Card>

## Step 3: Migrate to Nexus

<Card title="Nexus Migration" icon="arrow-right">
  Now perform the migration by updating the implementation to Nexus and initializing the Nexus account:

  ```typescript  theme={null}
  import { 
    encodeFunctionData,
    encodeAbiParameters
  } from "viem";

  async function migrateToNexus(V2Account: BiconomySmartAccountV2) {
    const V2AccountAddress = await V2Account.getAccountAddress();
    
    // Step 1: Update implementation to Nexus
    console.log("Preparing update implementation to Nexus...");
    const updateImplementationCalldata = encodeFunctionData({
      abi: [
        {
          name: "updateImplementation",
          type: "function",
          stateMutability: "nonpayable",
          inputs: [{ type: "address", name: "newImplementation" }],
          outputs: []
        }
      ],
      functionName: "updateImplementation",
      args: [config.nexusImplementationAddress],
    });
    
    const updateImplementationTransaction = {
      to: V2AccountAddress,
      data: updateImplementationCalldata,
    };
    
    // Step 2: Initialize Nexus Account
    console.log("Preparing initialize Nexus account...");
    const ownerAddress = config.eoaAddress;
    
    // Prepare initialization data for the validator
      const initData = encodeFunctionData({
        abi: [
          { 
            name: "initNexusWithDefaultValidator", type: "function",
             stateMutability: "nonpayable", 
             inputs: [
              { type: "bytes", name: "data" }
            ], 
            outputs: [] 
          }
        ],
        functionName: "initNexusWithDefaultValidator",
        args: [ownerAddress as `0x${string}`]
      });
    
    // Encode bootstrap data
    const initDataWithBootstrap = encodeAbiParameters(
      [
        { name: "bootstrap", type: "address" },
        { name: "initData", type: "bytes" },
      ],
      [config.nexusBootstrapAddress, initData]
    );
    
    // Create initializeAccount calldata
    const initializeNexusCalldata = encodeFunctionData({
      abi: [
        {
          name: "initializeAccount",
          type: "function",
          stateMutability: "nonpayable",
          inputs: [{ type: "bytes", name: "data" }],
          outputs: []
        }
      ],
      functionName: "initializeAccount",
      args: [initDataWithBootstrap],
    });
    
    const initializeNexusTransaction = {
      to: V2AccountAddress,
      data: initializeNexusCalldata,
    };
    
    // Send both transactions in a batch
    console.log("Sending migration transaction...");
    const migrateToNexusResponse = await V2Account.sendTransaction(
      [updateImplementationTransaction, initializeNexusTransaction],
      {
        paymasterServiceData: { mode: PaymasterMode.SPONSORED },
      }
    );
    
    const { transactionHash } = await migrateToNexusResponse.waitForTxHash();
    console.log("Migration transaction hash:", transactionHash);
    console.log("Migration completed successfully");
    
    return V2AccountAddress; // Return the address for the next step
  }
  ```
</Card>

## Step 4: Test Your Migrated Account

<Card title="Migration Verification" icon="test">
  After migration, verify that your account works correctly by creating a test transaction:

  ```typescript  theme={null}
  import { createBicoBundlerClient, toNexusAccount, getMEEVersion, MEEVersion } from "@biconomy/abstractjs";
  import { parseEther } from "viem";

  async function testMigratedAccount(accountAddress: string) : Promise<boolean> {
    // Connect to the migrated account using Nexus SDK
    const eoaAccount = privateKeyToAccount(config.eoaPrivateKey as `0x${string}`);
    
    const nexusAccount = createBicoBundlerClient({
      account: await toNexusAccount({
        signer: eoaAccount,
        chainConfiguration: {
          chain: config.chain,
          transport: http(),
          version: getMEEVersion(version)
        },
        // IMPORTANT: Use the same address as your V2 account
        accountAddress: accountAddress as `0x${string}`,
      }),
      transport: http(config.nexusBundlerUrl),
    });
    
    console.log("Testing migrated account...");
    
    // Send a test transaction
    const testHash = await nexusAccount.sendUserOperation({
      calls: [{
        to: config.eoaAddress as `0x${string}`,
        value: parseEther("0.00000001"),
      }],
    });
    
    console.log("Test transaction hash:", testHash);
    
    // Wait for the receipt (optional)
    const receipt = await nexusAccount.waitForUserOperationReceipt({ hash: testHash });
    console.log("Test transaction successful:", receipt.success);
    return receipt.success;
  }
  ```
</Card>

## Step 5: Update Your Application

<Card title="Application Update" icon="code">
  Update your application to use the Nexus SDK for all future interactions:

  ```typescript  theme={null}
  // IMPORTANT: Always use the same address as your V2 account
  const migratedAccountAddress = "YOUR_V2_ACCOUNT_ADDRESS";

  // Use this pattern for all future SDK interactions
  // Use the same version you used to get implementation address to upgrade to
  const nexusAccount = await toNexusAccount({
    signer: eoaAccount,
    chainConfiguration: {
      chain: base,
      transport: http(),
      version: getMEEVersion(version) 
    },
    accountAddress: migratedAccountAddress
  });

  const bundlerClient = createBicoBundlerClient({
    account: nexusAccount,
    transport: http(bundlerUrl)
  });
  ```
</Card>

## Troubleshooting

<CardGroup cols={1}>
  <Card title="Common Issues and Solutions" icon="help">
    If you encounter issues during migration:

    <Tabs>
      <Tab title="Migration Transaction Fails">
        <Steps>
          <Step title="Check Funds">
            Ensure your EOA has sufficient funds for gas
          </Step>

          <Step title="Verify Deployment">
            Verify the V2 account is properly deployed
          </Step>

          <Step title="Check Configuration">
            Check that all environment variables are set correctly
          </Step>
        </Steps>
      </Tab>

      <Tab title="Cannot Access Account After Migration">
        <Steps>
          <Step title="Verify Address">
            Make sure you're using the exact same address as your V2 account in the `accountAddress` parameter
          </Step>

          <Step title="Check Transaction">
            Verify the migration transaction completed successfully
          </Step>
        </Steps>
      </Tab>
    </Tabs>
  </Card>
</CardGroup>

## Next Steps

<Callout type="success">
  After successfully migrating your V2 account to Nexus:
</Callout>

<CardGroup cols={1}>
  <Card title="Post-Migration Actions" icon="check-circle">
    <Steps>
      <Step title="Store Account Address">
        **STORE YOUR ACCOUNT ADDRESS** in your application's persistent storage
      </Step>

      <Step title="Update Application Code">
        **Update your application code** to use the `accountAddress` parameter in all future interactions
      </Step>

      <Step title="Test Thoroughly">
        **Test thoroughly** with real transactions to ensure everything works as expected
      </Step>
    </Steps>
  </Card>
</CardGroup>

<Callout type="info">
  By following this migration guide and properly storing your account address, you've successfully upgraded your V2 account to a Nexus account while preserving its address, balance, and history.
</Callout>






# Smart Account V2 → Nexus

> Complete guide to migrate your BiconomyV2 smart accounts to the newer Nexus smart accounts

<Callout type="info">
  This guide explains how to migrate your BiconomySmartAccountV2 smart accounts to the newer Nexus smart accounts. The migration process preserves your account's address, balance, and history while upgrading to Nexus's enhanced architecture.
</Callout>

## Why Migrate?

<CardGroup cols={1}>
  <Card title="Benefits of Migration" icon="arrow-up">
    Migrating from V2 to Nexus smart accounts provides several benefits:

    <Steps>
      <Step title="Enhanced Security">
        Improved security model with modular validators
      </Step>

      <Step title="Better Performance">
        More gas-efficient transaction processing
      </Step>

      <Step title="Expanded Features">
        Access to the newest account abstraction capabilities
      </Step>

      <Step title="Future Compatibility">
        Ensure your smart account remains compatible with the latest AbstractJS SDK
      </Step>
    </Steps>
  </Card>
</CardGroup>

## Migration Process Overview

<CardGroup cols={1}>
  <Card title="Migration Steps" icon="list">
    The migration follows these steps:

    <Steps>
      <Step title="Connect to V2 Account">
        Connect to your existing V2 smart account
      </Step>

      <Step title="Deploy V2 Account">
        If not already deployed. Ensure the account is deployed on-chain
      </Step>

      <Step title="Migrate to Nexus">
        Update implementation and initialize the Nexus account
      </Step>

      <Step title="Verify Migration">
        Test the migrated account with a transaction
      </Step>

      <Step title="Update Your Application">
        Use the latest SDK to interact with the migrated account
      </Step>
    </Steps>
  </Card>
</CardGroup>

## Prerequisites

<Callout type="warning">
  Before starting the migration, ensure you have the following:
</Callout>

<CardGroup cols={1}>
  <Card title="Required Setup" icon="check">
    <Steps>
      <Step title="Update SDK">
        Update to the latest version of the AbstractJS SDK:

        ```bash  theme={null}
        npm install @biconomy/abstractjs
        ```
      </Step>

      <Step title="Prepare Credentials">
        Make sure you have your EOA's private key and the V2 account address
      </Step>
    </Steps>
  </Card>
</CardGroup>

## Step 1: Connect to Your V2 Account

<Card title="V2 Account Connection" icon="plug">
  First, set up the necessary connections to your V2 smart account:

  ```typescript  theme={null}
  import { createWalletClient, http } from "viem";
  import { privateKeyToAccount } from "viem/accounts";
  import { baseSepolia } from "viem/chains";
  import { 
    createSmartAccountClient as createV2Client,
    BiconomySmartAccountV2,
    PaymasterMode
  } from "@biconomy/account";
  import { getMEEVersion, MEEVersion } from "@biconomy/abstractjs";
  import dotenv from "dotenv";

  dotenv.config();

  // Use the version that suits your needs from the list
  // See MEE Versioning
  const version = MEEVersion.V2_1_0;
  const versionConfig = getMEEVersion(version)

  // Define configuration variables
  const config = {
    // Chain and network information
    chain: baseSepolia,
    
    // EOA credentials
    eoaPrivateKey: process.env.EOA_PRIVATE_KEY, // Replace with your private key
    eoaAddress: process.env.EOA_ADDRESS, // Replace with your EOA address
    
    // Biconomy infrastructure URLs
    v2BundlerUrl: process.env.V2_BUNDLER_URL, // Replace with your V2 bundler URL
    nexusBundlerUrl: process.env.NEXUS_BUNDLER_URL, // Replace with your Nexus bundler URL
    
    // API keys
    paymasterApiKey: process.env.PAYMASTER_API_KEY, // Replace with your Paymaster API key
    
    // Nexus contract addresses
    nexusImplementationAddress: versionConfig.implementationAddress,
    nexusBootstrapAddress: versionConfig.bootStrapAddress,
  };

  // Connect to your EOA
  const eoaAccount = privateKeyToAccount(config.eoaPrivateKey as `0x${string}`);
  const client = createWalletClient({
    account: eoaAccount,
    chain: config.chain,
    transport: http(),
  });

  // Connect to your V2 smart account
  const V2Account = await createV2Client({
    signer: client,
    biconomyPaymasterApiKey: config.paymasterApiKey,
    bundlerUrl: config.v2BundlerUrl!,
  });

  // Get V2 account address
  const V2AccountAddress = await V2Account.getAccountAddress();
  console.log("V2 Account Address:", V2AccountAddress);
  ```
</Card>

## Step 2: Check Deployment Status

<Card title="Account Deployment Check" icon="magnifying-glass">
  Check if your V2 account is already deployed, and deploy it if necessary:

  ```typescript  theme={null}
  // Check if account is deployed
  const isDeployed = await V2Account.isAccountDeployed();

  if (!isDeployed) {
    console.log("Account not deployed, deploying now...");
    
    // Deploy the V2 account
    const deploymentResponse = await V2Account.sendTransaction([
      {
        to: V2AccountAddress,
        value: 0n,
        data: "0x",
      },
    ]);

    const { transactionHash } = await deploymentResponse.waitForTxHash();
    console.log("V2 account deployment transaction hash:", transactionHash);
  } else {
    console.log("Account already deployed, proceeding with migration");
  }
  ```
</Card>

## Step 3: Migrate to Nexus

<Card title="Nexus Migration" icon="arrow-right">
  Now perform the migration by updating the implementation to Nexus and initializing the Nexus account:

  ```typescript  theme={null}
  import { 
    encodeFunctionData,
    encodeAbiParameters
  } from "viem";

  async function migrateToNexus(V2Account: BiconomySmartAccountV2) {
    const V2AccountAddress = await V2Account.getAccountAddress();
    
    // Step 1: Update implementation to Nexus
    console.log("Preparing update implementation to Nexus...");
    const updateImplementationCalldata = encodeFunctionData({
      abi: [
        {
          name: "updateImplementation",
          type: "function",
          stateMutability: "nonpayable",
          inputs: [{ type: "address", name: "newImplementation" }],
          outputs: []
        }
      ],
      functionName: "updateImplementation",
      args: [config.nexusImplementationAddress],
    });
    
    const updateImplementationTransaction = {
      to: V2AccountAddress,
      data: updateImplementationCalldata,
    };
    
    // Step 2: Initialize Nexus Account
    console.log("Preparing initialize Nexus account...");
    const ownerAddress = config.eoaAddress;
    
    // Prepare initialization data for the validator
      const initData = encodeFunctionData({
        abi: [
          { 
            name: "initNexusWithDefaultValidator", type: "function",
             stateMutability: "nonpayable", 
             inputs: [
              { type: "bytes", name: "data" }
            ], 
            outputs: [] 
          }
        ],
        functionName: "initNexusWithDefaultValidator",
        args: [ownerAddress as `0x${string}`]
      });
    
    // Encode bootstrap data
    const initDataWithBootstrap = encodeAbiParameters(
      [
        { name: "bootstrap", type: "address" },
        { name: "initData", type: "bytes" },
      ],
      [config.nexusBootstrapAddress, initData]
    );
    
    // Create initializeAccount calldata
    const initializeNexusCalldata = encodeFunctionData({
      abi: [
        {
          name: "initializeAccount",
          type: "function",
          stateMutability: "nonpayable",
          inputs: [{ type: "bytes", name: "data" }],
          outputs: []
        }
      ],
      functionName: "initializeAccount",
      args: [initDataWithBootstrap],
    });
    
    const initializeNexusTransaction = {
      to: V2AccountAddress,
      data: initializeNexusCalldata,
    };
    
    // Send both transactions in a batch
    console.log("Sending migration transaction...");
    const migrateToNexusResponse = await V2Account.sendTransaction(
      [updateImplementationTransaction, initializeNexusTransaction],
      {
        paymasterServiceData: { mode: PaymasterMode.SPONSORED },
      }
    );
    
    const { transactionHash } = await migrateToNexusResponse.waitForTxHash();
    console.log("Migration transaction hash:", transactionHash);
    console.log("Migration completed successfully");
    
    return V2AccountAddress; // Return the address for the next step
  }
  ```
</Card>

## Step 4: Test Your Migrated Account

<Card title="Migration Verification" icon="test">
  After migration, verify that your account works correctly by creating a test transaction:

  ```typescript  theme={null}
  import { createBicoBundlerClient, toNexusAccount, getMEEVersion, MEEVersion } from "@biconomy/abstractjs";
  import { parseEther } from "viem";

  async function testMigratedAccount(accountAddress: string) : Promise<boolean> {
    // Connect to the migrated account using Nexus SDK
    const eoaAccount = privateKeyToAccount(config.eoaPrivateKey as `0x${string}`);
    
    const nexusAccount = createBicoBundlerClient({
      account: await toNexusAccount({
        signer: eoaAccount,
        chainConfiguration: {
          chain: config.chain,
          transport: http(),
          version: getMEEVersion(version)
        },
        // IMPORTANT: Use the same address as your V2 account
        accountAddress: accountAddress as `0x${string}`,
      }),
      transport: http(config.nexusBundlerUrl),
    });
    
    console.log("Testing migrated account...");
    
    // Send a test transaction
    const testHash = await nexusAccount.sendUserOperation({
      calls: [{
        to: config.eoaAddress as `0x${string}`,
        value: parseEther("0.00000001"),
      }],
    });
    
    console.log("Test transaction hash:", testHash);
    
    // Wait for the receipt (optional)
    const receipt = await nexusAccount.waitForUserOperationReceipt({ hash: testHash });
    console.log("Test transaction successful:", receipt.success);
    return receipt.success;
  }
  ```
</Card>

## Step 5: Update Your Application

<Card title="Application Update" icon="code">
  Update your application to use the Nexus SDK for all future interactions:

  ```typescript  theme={null}
  // IMPORTANT: Always use the same address as your V2 account
  const migratedAccountAddress = "YOUR_V2_ACCOUNT_ADDRESS";

  // Use this pattern for all future SDK interactions
  // Use the same version you used to get implementation address to upgrade to
  const nexusAccount = await toNexusAccount({
    signer: eoaAccount,
    chainConfiguration: {
      chain: base,
      transport: http(),
      version: getMEEVersion(version) 
    },
    accountAddress: migratedAccountAddress
  });

  const bundlerClient = createBicoBundlerClient({
    account: nexusAccount,
    transport: http(bundlerUrl)
  });
  ```
</Card>

## Troubleshooting

<CardGroup cols={1}>
  <Card title="Common Issues and Solutions" icon="help">
    If you encounter issues during migration:

    <Tabs>
      <Tab title="Migration Transaction Fails">
        <Steps>
          <Step title="Check Funds">
            Ensure your EOA has sufficient funds for gas
          </Step>

          <Step title="Verify Deployment">
            Verify the V2 account is properly deployed
          </Step>

          <Step title="Check Configuration">
            Check that all environment variables are set correctly
          </Step>
        </Steps>
      </Tab>

      <Tab title="Cannot Access Account After Migration">
        <Steps>
          <Step title="Verify Address">
            Make sure you're using the exact same address as your V2 account in the `accountAddress` parameter
          </Step>

          <Step title="Check Transaction">
            Verify the migration transaction completed successfully
          </Step>
        </Steps>
      </Tab>
    </Tabs>
  </Card>
</CardGroup>

## Next Steps

<Callout type="success">
  After successfully migrating your V2 account to Nexus:
</Callout>

<CardGroup cols={1}>
  <Card title="Post-Migration Actions" icon="check-circle">
    <Steps>
      <Step title="Store Account Address">
        **STORE YOUR ACCOUNT ADDRESS** in your application's persistent storage
      </Step>

      <Step title="Update Application Code">
        **Update your application code** to use the `accountAddress` parameter in all future interactions
      </Step>

      <Step title="Test Thoroughly">
        **Test thoroughly** with real transactions to ensure everything works as expected
      </Step>
    </Steps>
  </Card>
</CardGroup>

<Callout type="info">
  By following this migration guide and properly storing your account address, you've successfully upgraded your V2 account to a Nexus account while preserving its address, balance, and history.
</Callout>





# MEE + EIP-7702 (Embedded Wallets)

EIP-7702 enables smart account features to be directly installed on an EOA. This allows orchestration without the user needing to fund or interact with a separate smart account.

<Warning>
  **Only Available on Some Wallets**: As of now, installing the authorization on the EOA is only available for users of Embedded Wallets - such as Privy, Dynamic, Turnkey, ... If your users are using External wallets, such as MetaMask, Rabby, etc... - then you need to use the [Fusion Mode](/new/getting-started/enable-mee-eoa-fusion)
</Warning>

<Steps>
  <Step title="Set Up Wallet Client">
    ```ts  theme={null}
    import { createWalletClient, http } from "viem";
    import { privateKeyToAccount } from "viem/accounts";

    const eoa = privateKeyToAccount(Bun.env.PRIVATE_KEY as `0x${string}`);

    const walletClient = createWalletClient({
      transport: http(),
    });
    ```
  </Step>

  <Step title="Sign Authorization">
    ```ts  theme={null}
    const nexus120Singleton = '0x000000004F43C49e93C970E84001853a70923B03';

    const authorization = await walletClient.signAuthorization({
      account: eoa,
      contractAddress: nexus120Singleton,

      // Chain ID 0 makes it valid across all chains
      chainId: 0, 

      // Use nonce 0 for fresh embedded wallet accounts
      nonce: 0    
    });
    ```

    <Warning>
      **Note for Embedded Wallets**: Privy, Dynamic, and other embedded wallets may expose their own `signAuthorization()` helper with the same parameters. In that case you can't use the `viem` `signAuthorization` method as it'll throw an error. Our docs have integration guides for every type of embedded wallet. You can follow them.
    </Warning>
  </Step>

  <Step title="Initialize Nexus Account">
    ```ts  theme={null}
    import { toMultichainNexusAccount, getMEEVersion, MEEVersion } from "@biconomy/abstractjs";
    import { base, optimism } from "viem/chains";
    import { http } from "viem";

    const orchestrator = await toMultichainNexusAccount({
      chainConfigurations: [
        {
          chain: optimism,
          transport: http(),
          version: getMEEVersion(MEEVersion.V2_1_0)
        },
        {
          chain: base,
          transport: http(),
          version: getMEEVersion(MEEVersion.V2_1_0)
        }
      ],
      signer: eoa,

      // Must be overridden when using EIP-7702
      accountAddress: eoa.address 
    });
    ```
  </Step>

  <Step title="Connect to MEE Relayer">
    ```ts  theme={null}
    import { createMeeClient } from "@biconomy/abstractjs";

    const meeClient = await createMeeClient({
      account: orchestrator
    });
    ```
  </Step>

  <Step title="Quote Orchestration">
    ```ts  theme={null}
    import { zeroAddress } from "viem";
    import { usdcAddresses } from "../utils/addresses/usdc.addresses";

    const quote = await meeClient.getQuote({
      instructions: [{
        calls: [{
          to: zeroAddress,
          value: 0n
        }],
        chainId: optimism.id
      }],

      // Must be set for EIP-7702-based orchestration
      delegate: true,          
      
      // Can be passed manually or signed by the SDK
      authorization,          

      feeToken: {
        address: usdcAddresses[base.id],
        chainId: base.id
      },
    });

    console.log(quote.paymentInfo.tokenAmount);
    ```

    <Info>
      **Passing Authorizations**: We recommend passing authorizations manually as it gives you more control over signing for different chains and wallet providers. However, if you'd just like our SDK to automatically prompt users to sign authorizations, you can omit the `authorizations` field and just set `delegate: true`
    </Info>
  </Step>

  <Step title="Execute Orchestration">
    ```ts  theme={null}
    const { hash } = await meeClient.executeQuote({ quote });

    const receipt = await meeClient.waitForSupertransactionReceipt({ hash });
    ```
  </Step>
</Steps>

## Notes

* `delegate: true` is **mandatory**.
* `authorization` must be passed. You can pass it manually (recommended) or allow the SDK to prompt the user to sign.
* `accountAddress` must be **explicitly overridden** to the EOA address to signal EIP-7702 usage.
* The Nexus smart account logic will be executed directly on the EOA address.




# MEE + Fusion (External Wallets)

External wallets, such as MetaMask or Rabby, do not permit direct installation of smart account logic on EOAs. To enable MEE orchestration in this case, **Fusion Mode** is used. It relies on a passthrough mechanism involving a Companion smart account and a signed **trigger transaction**.

<img style={{ height: 400 }} src="https://i.imgur.com/G5EvlNe.png" />

<Note>
  We recommend understanding Fusion Execution before executing code, but if you'd like to skip the theory - [read the code guide](/new/getting-started/pay-gas-erc20-token#-2-fusion-mode-used-with-external-wallets)
</Note>

## Fusion Mode Flow

<Steps>
  <Step title="Trigger Signature">
    The user signs a *trigger transaction* that includes the hash of all orchestration instructions. This signature authorizes the full orchestration with a single user action.
  </Step>

  <Step title="Funds Transferred to Companion Account">
    Funds are temporarily pulled into a *Companion Account* fully owned by the user. This account is non-custodial and stateless—no funds are stored there beyond execution.
  </Step>

  <Step title="Instruction Execution">
    All instructions (e.g., swaps, bridges, multicalls) are executed using the Companion Account.
  </Step>

  <Step title="Return to EOA">
    Resulting assets are sent back to the user's EOA. The Companion Account is left clean with no dust.
  </Step>

  <Step title="Optional Cleanup">
    If an orchestration step fails—especially in multichain setups—a cleanup can revert intermediate steps, returning funds or rebalancing tokens.
  </Step>
</Steps>

Fusion Mode allows orchestrated execution even without embedded wallet features, enabling advanced UX with any external wallet.

## Trigger Types

There are two kinds of Fusion triggers. They depend on which type of token you are using as the input token.

If you're working with tokens which support `ERC20Permit` then you can use the `ERC20Permit` trigger type, which makes the entire orchestration gasless. Otherwise, you must use the `Onchain Tx` trigger, which requires a bit of gas on source chain to execute the `approve` ERC20 transaction.

<Table>
  <thead>
    <tr>
      <th>Trigger Type</th>
      <th>How it Works</th>
      <th>Gas Required</th>
      <th>Token Support</th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>**ERC20Permit**</td>
      <td>Uses ERC-2612 signature to permit spending. Orchestration hash is packed into the `deadline` field.</td>
      <td>No</td>
      <td>Only ERC-2612 tokens</td>
    </tr>

    <tr>
      <td>**Onchain Tx**</td>
      <td>Any EVM transaction that includes orchestration instructions. Most often an `approve()` call.</td>
      <td>Yes</td>
      <td>All token types</td>
    </tr>
  </tbody>
</Table>

The SDK will detect whether a token supports ERC-2612 and choose the appropriate trigger type.

## Fusion Constraints

* Can **only consume one token per user signature**.
* Token used for execution must also be used to pay for gas.
* **Transaction sponsorship** is possible and bypasses the gas requirement.

## Fusion Flow

1. **Trigger**: User signs a transaction (e.g. `approve`) that signals orchestration.
2. **Orchestrate**: MEE nodes execute function calls, bridges, or other logic.
3. **Return**: Final steps return assets to the user's EOA.

<Info>
  **Stateless UX**: Users never need to know about the orchestrator account. All resulting tokens return to the user's EOA automatically.
</Info>






# MEE + Fusion (External Wallets)

External wallets, such as MetaMask or Rabby, do not permit direct installation of smart account logic on EOAs. To enable MEE orchestration in this case, **Fusion Mode** is used. It relies on a passthrough mechanism involving a Companion smart account and a signed **trigger transaction**.

<img style={{ height: 400 }} src="https://i.imgur.com/G5EvlNe.png" />

<Note>
  We recommend understanding Fusion Execution before executing code, but if you'd like to skip the theory - [read the code guide](/new/getting-started/pay-gas-erc20-token#-2-fusion-mode-used-with-external-wallets)
</Note>

## Fusion Mode Flow

<Steps>
  <Step title="Trigger Signature">
    The user signs a *trigger transaction* that includes the hash of all orchestration instructions. This signature authorizes the full orchestration with a single user action.
  </Step>

  <Step title="Funds Transferred to Companion Account">
    Funds are temporarily pulled into a *Companion Account* fully owned by the user. This account is non-custodial and stateless—no funds are stored there beyond execution.
  </Step>

  <Step title="Instruction Execution">
    All instructions (e.g., swaps, bridges, multicalls) are executed using the Companion Account.
  </Step>

  <Step title="Return to EOA">
    Resulting assets are sent back to the user's EOA. The Companion Account is left clean with no dust.
  </Step>

  <Step title="Optional Cleanup">
    If an orchestration step fails—especially in multichain setups—a cleanup can revert intermediate steps, returning funds or rebalancing tokens.
  </Step>
</Steps>

Fusion Mode allows orchestrated execution even without embedded wallet features, enabling advanced UX with any external wallet.

## Trigger Types

There are two kinds of Fusion triggers. They depend on which type of token you are using as the input token.

If you're working with tokens which support `ERC20Permit` then you can use the `ERC20Permit` trigger type, which makes the entire orchestration gasless. Otherwise, you must use the `Onchain Tx` trigger, which requires a bit of gas on source chain to execute the `approve` ERC20 transaction.

<Table>
  <thead>
    <tr>
      <th>Trigger Type</th>
      <th>How it Works</th>
      <th>Gas Required</th>
      <th>Token Support</th>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>**ERC20Permit**</td>
      <td>Uses ERC-2612 signature to permit spending. Orchestration hash is packed into the `deadline` field.</td>
      <td>No</td>
      <td>Only ERC-2612 tokens</td>
    </tr>

    <tr>
      <td>**Onchain Tx**</td>
      <td>Any EVM transaction that includes orchestration instructions. Most often an `approve()` call.</td>
      <td>Yes</td>
      <td>All token types</td>
    </tr>
  </tbody>
</Table>

The SDK will detect whether a token supports ERC-2612 and choose the appropriate trigger type.

## Fusion Constraints

* Can **only consume one token per user signature**.
* Token used for execution must also be used to pay for gas.
* **Transaction sponsorship** is possible and bypasses the gas requirement.

## Fusion Flow

1. **Trigger**: User signs a transaction (e.g. `approve`) that signals orchestration.
2. **Orchestrate**: MEE nodes execute function calls, bridges, or other logic.
3. **Return**: Final steps return assets to the user's EOA.

<Info>
  **Stateless UX**: Users never need to know about the orchestrator account. All resulting tokens return to the user's EOA automatically.
</Info>

