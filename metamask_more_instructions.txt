MetaMask Smart Accounts quickstart
You can get started quickly with MetaMask Smart Accounts by creating your first smart account and sending a user operation.

Prerequisites
Install Node.js v18 or later.
Install Yarn, npm, or another package manager.
Steps
1. Install the toolkit
Install the MetaMask Delegation Toolkit:

npm
Yarn
pnpm
Bun
npm install @metamask/delegation-toolkit
2. Set up a Public Client
Set up a Viem Public Client using Viem's createPublicClient function. This client will let the smart account query the signer's account state and interact with blockchain network.

import { createPublicClient, http } from "viem";
import { sepolia as chain } from "viem/chains";

const publicClient = createPublicClient({
  chain,
  transport: http(),
});
3. Set up a Bundler Client
Set up a Viem Bundler Client using Viem's createBundlerClient function. This lets you use the bundler service to estimate gas for user operations and submit transactions to the network.

import { createBundlerClient } from "viem/account-abstraction";

const bundlerClient = createBundlerClient({
  client: publicClient,
  transport: http("https://your-bundler-rpc.com"),
});
4. Create a MetaMask smart account
Create a MetaMask smart account to send the first user operation.

This example configures a Hybrid smart account, which is a flexible smart account implementation that supports both an externally owned account (EOA) owner and any number of passkey (WebAuthn) signers:

import { Implementation, toMetaMaskSmartAccount } from "@metamask/delegation-toolkit";
import { privateKeyToAccount } from "viem/accounts";

const account = privateKeyToAccount("0x...");

const smartAccount = await toMetaMaskSmartAccount({
  client: publicClient,
  implementation: Implementation.Hybrid,
  deployParams: [account.address, [], [], []],
  deploySalt: "0x",
  signer: { account },
});
5. Send a user operation
Send a user operation using Viem's sendUserOperation method.

See Send a user operation to learn how to estimate fee per gas, and wait for the transaction receipt.

The smart account will remain counterfactual until the first user operation. If the smart account is not deployed, it will be automatically deployed upon the sending first user operation.

import { parseEther } from "viem";

// Appropriate fee per gas must be determined for the specific bundler being used.
const maxFeePerGas = 1n;
const maxPriorityFeePerGas = 1n;

const userOperationHash = await bundlerClient.sendUserOperation({
  account: smartAccount,
  calls: [
    {
      to: "0x1234567890123456789012345678901234567890",
      value: parseEther("1"),
    },
  ],
  maxFeePerGas,
  maxPriorityFeePerGas,
});




Create a smart account
You can enable users to create a MetaMask smart account directly in your dapp. This page provides examples of using toMetaMaskSmartAccount with Viem Core SDK to create different types of smart accounts with different signature schemes. An account's supported signatories can sign data on behalf of the smart account.

Prerequisites
Install and set up the Delegation Toolkit.

Create a Hybrid smart account
A Hybrid smart account supports both an externally owned account (EOA) owner and any number of passkey (WebAuthn) signers. You can create a Hybrid smart account with the following types of signers.

Create a Hybrid smart account with an Account signer
Use toMetaMaskSmartAccount, and Viem's privateKeyToAccount and generatePrivateKey, to create a Hybrid smart account with a signer from a randomly generated private key:
import { publicClient } from "./client.ts"
import { account } from "./signer.ts";
import { 
  Implementation, 
  toMetaMaskSmartAccount,
} from "@metamask/delegation-toolkit";

const smartAccount = await toMetaMaskSmartAccount({
  client: publicClient,
  implementation: Implementation.Hybrid,
  deployParams: [account.address, [], [], []],
  deploySalt: "0x",
  signer: { account },
});


import { http, createPublicClient } from "viem";
import { sepolia as chain } from "viem/chains";

const transport = http(); 
export const publicClient = createPublicClient({ 
  transport, 
  chain, 
});



import { privateKeyToAccount, generatePrivateKey } from "viem/accounts";

const privateKey = generatePrivateKey(); 
export const account = privateKeyToAccount(privateKey);




Create a Hybrid smart account with a Wallet Client signer
Use toMetaMaskSmartAccount and Viem's createWalletClient to create a Hybrid smart account with a Wallet Client signer:
import { publicClient } from "./client.ts"
import { walletClient } from "./signer.ts";
import { 
  Implementation, 
  toMetaMaskSmartAccount,
} from "@metamask/delegation-toolkit";

const addresses = await walletClient.getAddresses();
const owner = addresses[0];

const smartAccount = await toMetaMaskSmartAccount({
  client: publicClient,
  implementation: Implementation.Hybrid,
  deployParams: [owner, [], [], []],
  deploySalt: "0x",
  signer: { walletClient },
});


import { http, createPublicClient } from "viem";
import { sepolia as chain } from "viem/chains";

const transport = http(); 
export const publicClient = createPublicClient({ 
  transport, 
  chain, 
});



import { privateKeyToAccount, generatePrivateKey } from "viem/accounts";
import { sepolia as chain } from "viem/chains";
import { http, createWalletClient } from "viem";

const privateKey = generatePrivateKey(); 
const account = privateKeyToAccount(privateKey);

export const walletClient = createWalletClient({
  account,
  chain,
  transport: http()
})







Create a Hybrid smart account with a passkey signer
Use toMetaMaskSmartAccount and Viem's toWebAuthnAccount to create a Hybrid smart account with a passkey (WebAuthn) signer:
Installation required
To work with WebAuthn, install the Ox SDK.

Ox – Ethereum Standard Library
Overview
Ox (⦻) is the foundation of robust Ethereum software written in TypeScript. It is an Ethereum Standard Library that provides a set of lightweight, performant, and type-safe TypeScript modules for Ethereum.

It offers core utilities & types for primitives such as: ABIs, Addresses, Blocks, Bytes, ECDSA, Hex, JSON-RPC, RLP, Signatures, Transactions, and more.

As an unopinionated Standard Library, it is designed to be used by higher-level consumers (such as Viem, Tevm, etc) to provide their own opinionated interfaces, and/or when reaching for low-level primitives may be needed without buying into a Client Abstraction stack (Viem, Ethers, Web3.js, etc).

Installation
npm
pnpm
bun

npm i ox
Example Usage
Below is an example of using the Hex and Rlp modules of Ox.


import { Hex, Rlp } from 'ox'
 
const rlp = Rlp.fromHex([Hex.fromString('hello'), Hex.fromString('world')])
Using Named Imports aligns closer with Ox's philosophy of module-driven Standard Library development, which enables categorical grouping of utilities and intuitive editor autocompletion. This does not compromise on tree-shakability and application bundle size.

How to Read These Docs
The documentation is split into two main sections – Guides and the API Reference – as displayed on the sidebar.

If you are new to Ox, you can start by reading the Guides or you can use the Search Bar (/) to find the Modules you may be looking for.

You can also skim the API Reference to get a quick overview of the available Modules. Each Module has a brief overview of its purpose, as well as some examples (Example) – it can be seen as a "mini-guide" in addition to the formal Guides.

Ox's API is organized by Module (Example), and each Module is further broken down into its individual Function (Example).




Create a Stateless 7702 smart account
A Stateless 7702 smart account represents an EOA that has been upgraded to support MetaMask Smart Accounts functionality as defined by EIP-7702.

note
This implementation does not handle the upgrade process; see the EIP-7702 quickstart to learn how to upgrade.

EIP-7702 quickstart
This quickstart demonstrates how to upgrade your externally owned account (EOA) to support MetaMask Smart Accounts functionality using an EIP-7702 transaction. This enables your EOA to leverage the benefits of account abstraction, such as batch transactions, gas sponsorship, and delegation capabilities.

Prerequisites
Install Node.js v18 or later.
Install Yarn, npm, or another package manager.
Install Viem.
Steps
1. Install the toolkit
Install the MetaMask Delegation Toolkit:

npm
Yarn
pnpm
Bun
npm install @metamask/delegation-toolkit
2. Set up a Public Client
Set up a Viem Public Client using Viem's createPublicClient function. This client will let the EOA query the account state and interact with blockchain network.

import { createPublicClient, http } from "viem";
import { sepolia as chain } from "viem/chains";
 
const publicClient = createPublicClient({
  chain,
  transport: http(),
});
3. Set up a Bundler Client
Set up a Viem Bundler Client using Viem's createBundlerClient function. This lets you use the bundler service to estimate gas for user operations and submit transactions to the network.

import { createBundlerClient } from "viem/account-abstraction";

const bundlerClient = createBundlerClient({
  client: publicClient,
  transport: http("https://your-bundler-rpc.com"),
});
4. Set up a Wallet Client
Set up Viem Wallet Client using Viem's createWalletClient function. This lets you sign and submit EIP-7702 authorization.

import { createWalletClient, http } from "viem";
import { sepolia as chain } from "viem/chains";
import { privateKeyToAccount } from "viem/accounts";
 
export const account = privateKeyToAccount("0x...");
 
export const walletClient = createWalletClient({
  account,
  chain,
  transport: http(),
});
5. Authorize a 7702 delegation
Create an authorization to map the contract code to an EOA, and sign it using Viem's signAuthorization action. The signAuthorization action does not support JSON-RPC accounts.

This example uses EIP7702StatelessDeleGator as the EIP-7702 delegator contract. It follows a stateless design, as it does not store signer data in the contract's state. This approach provides a lightweight and secure way to upgrade an EOA to a smart account.

import {
  Implementation,
  toMetaMaskSmartAccount,
  getDeleGatorEnvironment,
} from "@metamask/delegation-toolkit";
import { privateKeyToAccount } from "viem/accounts";

const environment = getDeleGatorEnvironment(sepolia.id);
const contractAddress = environment.implementations.EIP7702StatelessDeleGatorImpl;

const authorization = await walletClient.signAuthorization({
  account, 
  contractAddress,
  executor: "self", 
});
6. Submit the authorization
Once you have signed an authorization, you can send an EIP-7702 transaction to set the EOA code. Since the authorization cannot be sent by itself, you can include it alongside a dummy transaction.

import { zeroAddress } from "viem";

const hash = await walletClient.sendTransaction({ 
  authorizationList: [authorization], 
  data: "0x", 
  to: zeroAddress, 
});
7. Create a MetaMask smart account
Create a smart account instance for the EOA and start leveraging the benefits of account abstraction.

import { 
  Implementation, 
  toMetaMaskSmartAccount,
} from "@metamask/delegation-toolkit";

const addresses = await walletClient.getAddresses();
const address = addresses[0];

const smartAccount = await toMetaMaskSmartAccount({
  client: publicClient,
  implementation: Implementation.Stateless7702,
  address, 
  signer: { walletClient },
});
8. Send a user operation
Send a user operation through the upgraded EOA, using Viem's sendUserOperation method.

import { parseEther } from "viem";

// Appropriate fee per gas must be determined for the specific bundler being used.
const maxFeePerGas = 1n;
const maxPriorityFeePerGas = 1n;

const userOperationHash = await bundlerClient.sendUserOperation({
  account: smartAccount,
  calls: [
    {
      to: "0x1234567890123456789012345678901234567890",
      value: parseEther("1")
    }
  ],
  maxFeePerGas,
  maxPriorityFeePerGas
});



You can create a Stateless 7702 smart account with the following types of signatories.

Create a Stateless 7702 smart account with an account signer
Use toMetaMaskSmartAccount and Viem's privateKeyToAccount to create a Stateless 7702 smart account with a signer from a private key:

import { publicClient } from "./client.ts";
import { account } from "./signer.ts";
import { 
  Implementation, 
  toMetaMaskSmartAccount,
} from "@metamask/delegation-toolkit";

const smartAccount = await toMetaMaskSmartAccount({
  client: publicClient,
  implementation: Implementation.Stateless7702,
  address: account.address // Address of the upgraded EOA
  signer: { account },
});


import { http, createPublicClient } from "viem";
import { sepolia as chain } from "viem/chains";

const transport = http(); 
export const publicClient = createPublicClient({ 
  transport, 
  chain, 
});


import { privateKeyToAccount, generatePrivateKey } from "viem/accounts";

const privateKey = generatePrivateKey(); 
export const account = privateKeyToAccount(privateKey);



Create a Stateless 7702 smart account with a Wallet Client signer
Use toMetaMaskSmartAccount and Viem's createWalletClient to create a Stateless 7702 smart account with a Wallet Client signer:

example.ts
client.ts
signer.ts


import { publicClient } from "./client.ts";
import { walletClient } from "./signer.ts";
import { 
  Implementation, 
  toMetaMaskSmartAccount,
} from "@metamask/delegation-toolkit";

const addresses = await walletClient.getAddresses();
const address = addresses[0];

const smartAccount = await toMetaMaskSmartAccount({
  client: publicClient,
  implementation: Implementation.Stateless7702,
  address, // Address of the upgraded EOA
  signer: { walletClient },
});


import { http, createPublicClient } from "viem";
import { sepolia as chain } from "viem/chains";

const transport = http(); 
export const publicClient = createPublicClient({ 
  transport, 
  chain, 
});




import { privateKeyToAccount, generatePrivateKey } from "viem/accounts";
import { sepolia as chain } from "viem/chains";
import { http, createWalletClient } from "viem";

const privateKey = generatePrivateKey(); 
const account = privateKeyToAccount(privateKey);

export const walletClient = createWalletClient({
  account,
  chain,
  transport: http(),
})







Configure the Delegation Toolkit
The MetaMask Delegation toolkit is highly configurable, providing support for custom bundlers and paymasters. You can also configure the toolkit environment to interact with the Delegation Framework.

Prerequisites
Install and set up the Delegation Toolkit.

Configure the bundler
The toolkit uses Viem's Account Abstraction API to configure custom bundlers and paymasters. This provides a robust and flexible foundation for creating and managing MetaMask Smart Accounts. See Viem's account abstraction documentation for more information on the API's features, methods, and best practices.

To use the bundler and paymaster clients with the toolkit, create instances of these clients and configure them as follows:

import {
  createPaymasterClient,
  createBundlerClient,
} from "viem/account-abstraction";
import { http } from "viem";
import { sepolia as chain } from "viem/chains"; 

// Replace these URLs with your actual bundler and paymaster endpoints.
const bundlerUrl = "https://your-bundler-url.com";
const paymasterUrl = "https://your-paymaster-url.com";

// The paymaster is optional.
const paymasterClient = createPaymasterClient({
  transport: http(paymasterUrl),
});

const bundlerClient = createBundlerClient({
  transport: http(bundlerUrl),
  paymaster: paymasterClient,
  chain,
});
Replace the bundler and paymaster URLs with your bundler and paymaster endpoints. For example, you can use endpoints from Pimlico, Infura, or ZeroDev.

note
Providing a paymaster is optional when configuring your bundler client. However, if you choose not to use a paymaster, the smart contract account must have enough funds to pay gas fees.

(Optional) Configure the toolkit environment
The toolkit environment (DeleGatorEnvironment) defines the contract addresses necessary for interacting with the Delegation Framework on a specific network. It serves several key purposes:

It provides a centralized configuration for all the contract addresses required by the Delegation Framework.
It enables easy switching between different networks (for example, Mainnet and testnet) or custom deployments.
It ensures consistency across different parts of the application that interact with the Delegation Framework.
Resolve the environment
When you create a MetaMask smart account, the toolkit automatically resolves the environment based on the version it requires and the chain configured. If no environment is found for the specified chain, it throws an error.



example.ts
config.ts



import { DeleGatorEnvironment } from "@metamask/delegation-toolkit";
import { delegatorSmartAccount } from "./config.ts";

const environment: DeleGatorEnvironment = delegatorSmartAccount.environment; 




import {
  Implementation,
  toMetaMaskSmartAccount,
} from "@metamask/delegation-toolkit";
import { privateKeyToAccount } from "viem/accounts";
import { createPublicClient, http } from "viem";
import { sepolia as chain } from "viem/chains";
 
const publicClient = createPublicClient({
  chain,
  transport: http(),
});

const delegatorAccount = privateKeyToAccount("0x...");

const delegatorSmartAccount = await toMetaMaskSmartAccount({
  client: publicClient,
  implementation: Implementation.Hybrid,
  deployParams: [delegatorAccount.address, [], [], []],
  deploySalt: "0x",
  signer: { account: delegatorAccount },
});

export delegatorSmartAccount;



note
See the changelog of the toolkit version you are using (in the left sidebar) for supported chains.

Alternatively, you can use the getDelegatorEnvironment function to resolve the environment. This function is especially useful if your delegator is not a smart account when creating a redelegation.

import { 
  getDeleGatorEnvironment, 
  DeleGatorEnvironment, 
} from "@metamask/delegation-toolkit"; 

// Resolves the DeleGatorEnvironment for Sepolia
const environment: DeleGatorEnvironment = getDelegatorEnvironment(11155111);
Deploy a custom environment
You can deploy the contracts using any method, but the toolkit provides a convenient deployDelegatorEnvironment function. This function simplifies deploying the Delegation Framework contracts to your desired EVM chain.

This function requires a Viem Public Client, Wallet Client, and Chain to deploy the contracts and resolve the DeleGatorEnvironment.

Your wallet must have a sufficient native token balance to deploy the contracts.

example.ts
config.ts




import { walletClient, publicClient } from "./config.ts";
import { sepolia as chain } from "viem/chains";
import { deployDeleGatorEnvironment } from "@metamask/delegation-toolkit/utils";

const environment = await deployDeleGatorEnvironment(
  walletClient, 
  publicClient, 
  chain
);


import { privateKeyToAccount } from "viem/accounts";
import { sepolia as chain } from "viem/chains";
import { http, createWalletClient, createPublicClient } from "viem";

// Your deployer wallet private key.
const privateKey = "0x123.."; 
const account = privateKeyToAccount(privateKey);

export const walletClient = createWalletClient({
  account,
  chain,
  transport: http()
});
 
export const publicClient = createPublicClient({ 
  transport: http(), 
  chain, 
});



You can also override specific contracts when calling deployDelegatorEnvironment. For example, if you've already deployed the EntryPoint contract on the target chain, you can pass the contract address to the function.

// The config.ts is the same as in the previous example.
import { walletClient, publicClient } from "./config.ts";
import { sepolia as chain } from "viem/chains";
import { deployDeleGatorEnvironment } from "@metamask/delegation-toolkit/utils";

const environment = await deployDeleGatorEnvironment(
  walletClient, 
  publicClient, 
  chain,
+ {
+   EntryPoint: "0x0000000071727De22E5E9d8BAf0edAc6f37da032"
+ }
);
Once the contracts are deployed, you can use them to override the environment.

Override the environment
To override the environment, the toolkit provides an overrideDeployedEnvironment function to resolve DeleGatorEnvironment with specified contracts for the given chain and contract version.

// The config.ts is the same as in the previous example.
import { walletClient, publicClient } from "./config.ts";
import { sepolia as chain } from "viem/chains";
import { DeleGatorEnvironment } from "@metamask/delegation-toolkit";
import { 
  overrideDeployedEnvironment,
  deployDeleGatorEnvironment 
} from "@metamask/delegation-toolkit/utils";

const environment: DeleGatorEnvironment = await deployDeleGatorEnvironment(
  walletClient, 
  publicClient, 
  chain
);

overrideDeployedEnvironment(
  chain.id,
  "1.3.0",
  environment,
);
If you've already deployed the contracts using a different method, you can create a DelegatorEnvironment instance with the required contract addresses, and pass it to the function.

- import { walletClient, publicClient } from "./config.ts";
- import { sepolia as chain } from "viem/chains";
import { DeleGatorEnvironment } from "@metamask/delegation-toolkit";
import { 
  overrideDeployedEnvironment,
- deployDeleGatorEnvironment
} from "@metamask/delegation-toolkit/utils";

- const environment: DeleGatorEnvironment = await deployDeleGatorEnvironment(
-  walletClient, 
-  publicClient, 
-  chain
- );

+ const environment: DeleGatorEnvironment = {
+  SimpleFactory: "0x124..",
+  // ...
+  implementations: {
+    // ...
+  },
+ };

overrideDeployedEnvironment(
  chain.id,
  "1.3.0",
  environment
);
note
Make sure to specify the Delegation Framework version required by the toolkit. See the changelog of the toolkit version you are using (in the left sidebar) for its required Framework version.




Deploy a smart account
You can deploy MetaMask Smart Accounts in two different ways. You can either deploy a smart account automatically when sending the first user operation, or manually deploy the account.

Prerequisites
Install and set up the Delegation Toolkit.
Create a MetaMask smart account.
Deploy with the first user operation
When you send the first user operation from a smart account, the Delegation Toolkit checks whether the account is already deployed. If the account is not deployed, the toolkit adds the initCode to the user operation to deploy the account within the same operation. Internally, the initCode is encoded using the factory and factoryData.

example.ts
config.ts



import { bundlerClient, smartAccount } from "./config.ts";
import { parseEther } from "viem";

// Appropriate fee per gas must be determined for the specific bundler being used.
const maxFeePerGas = 1n;
const maxPriorityFeePerGas = 1n;

const userOperationHash = await bundlerClient.sendUserOperation({
  account: smartAccount,
  calls: [
    {
      to: "0x1234567890123456789012345678901234567890",
      value: parseEther("0.001"),
    }
  ],
  maxFeePerGas,
  maxPriorityFeePerGas
});



import { createPublicClient, http } from "viem";
import { createBundlerClient } from "viem/account-abstraction";
import { sepolia as chain } from "viem/chains";
import { generatePrivateKey, privateKeyToAccount } from "viem/accounts";
import { 
  Implementation, 
  toMetaMaskSmartAccount,
} from "@metamask/delegation-toolkit";


const publicClient = createPublicClient({
  chain,
  transport: http()
});

const privateKey = generatePrivateKey(); 
const account = privateKeyToAccount(privateKey);

export const smartAccount = await toMetaMaskSmartAccount({
  client: publicClient,
  implementation: Implementation.Hybrid,
  deployParams: [account.address, [], [], []],
  deploySalt: "0x",
  signer: { account },
});

export const bundlerClient = createBundlerClient({
  client: publicClient,
  transport: http("https://public.pimlico.io/v2/11155111/rpc")
});




Deploy manually
To deploy a smart account manually, call the getFactoryArgs method from the smart account to retrieve the factory and factoryData. This allows you to use a relay account to sponsor the deployment without needing a paymaster.

The factory represents the contract address responsible for deploying the smart account, while factoryData contains the calldata that will be executed by the factory to deploy the smart account.

The relay account can be either an externally owned account (EOA) or another smart account. This example uses an EOA.

example.ts
config.ts



import { walletClient, smartAccount } from "./config.ts";

const { factory, factoryData } = await smartAccount.getFactoryArgs();

// Deploy smart account using relay account.
const hash = await walletClient.sendTransaction({
  to: factory,
  data: factoryData,
})



import { createPublicClient, createWalletClient, http } from "viem";
import { sepolia as chain } from "viem/chains";
import { generatePrivateKey, privateKeyToAccount } from "viem/accounts";
import { 
  Implementation, 
  toMetaMaskSmartAccount,
} from "@metamask/delegation-toolkit";


const publicClient = createPublicClient({
  chain,
  transport: http()
});

const privateKey = generatePrivateKey(); 
const account = privateKeyToAccount(privateKey);

export const smartAccount = await toMetaMaskSmartAccount({
  client: publicClient,
  implementation: Implementation.Hybrid,
  deployParams: [account.address, [], [], []],
  deploySalt: "0x",
  signer: { account },
});

const relayAccountPrivateKey = "0x121..";
const relayAccount = privateKeyToAccount(relayAccountPrivateKey)

export const walletClient = createWalletClient({
  account: relayAccount,
  chain,
  transport: http()
})





Send a user operation
User operations are the ERC-4337 counterpart to traditional blockchain transactions. They incorporate significant enhancements that improve user experience and provide greater flexibility in account management and transaction execution.

Viem's Account Abstraction API allows a developer to specify an array of Calls that will be executed as a user operation via Viem's sendUserOperation method. The MetaMask Delegation Toolkit encodes and executes the provided calls.

User operations are not directly sent to the network. Instead, they are sent to a bundler, which validates, optimizes, and aggregates them before network submission. See Viem's Bundler Client for details on how to interact with the bundler.

note
If a user operation is sent from a MetaMask smart account that has not been deployed, the toolkit configures the user operation to automatically deploy the account.

Prerequisites
Install and set up the Delegation Toolkit.
Create a MetaMask smart account.
Send a user operation
The following is a simplified example of sending a user operation using Viem Core SDK. Viem Core SDK offers more granular control for developers who require it.

In the example, a user operation is created with the necessary gas limits.

This user operation is passed to a bundler instance, and the EntryPoint address is retrieved from the client.

example.ts
config.ts



import { bundlerClient, smartAccount } from "./config.ts";
import { parseEther } from "viem";

// Appropriate fee per gas must be determined for the specific bundler being used.
const maxFeePerGas = 1n;
const maxPriorityFeePerGas = 1n;

const userOperationHash = await bundlerClient.sendUserOperation({
  account: smartAccount,
  calls: [
    {
      to: "0x1234567890123456789012345678901234567890",
      value: parseEther("0.001")
    }
  ],
  maxFeePerGas,
  maxPriorityFeePerGas
});




import { createPublicClient, http } from "viem";
import { createBundlerClient } from "viem/account-abstraction";
import { sepolia as chain } from "viem/chains";
import { generatePrivateKey, privateKeyToAccount } from "viem/accounts";
import { 
  Implementation, 
  toMetaMaskSmartAccount,
} from "@metamask/delegation-toolkit";


const publicClient = createPublicClient({
  chain,
  transport: http()
});

const privateKey = generatePrivateKey(); 
const account = privateKeyToAccount(privateKey);

export const smartAccount = await toMetaMaskSmartAccount({
  client: publicClient,
  implementation: Implementation.Hybrid,
  deployParams: [account.address, [], [], []],
  deploySalt: "0x",
  signer: { account },
});

export const bundlerClient = createBundlerClient({
  client: publicClient,
  transport: http("https://public.pimlico.io/v2/11155111/rpc")
});




Estimate fee per gas
Different bundlers have different ways to estimate maxFeePerGas and maxPriorityFeePerGas, and can reject requests with insufficient values. The following example updates the previous example to estimate the fees.

This example uses constant values, but the Hello Gator example uses Pimlico's Alto bundler, which fetches user operation gas price using the RPC method pimlico_getUserOperationPrice.

Installation required
To estimate the gas fee for Pimlico's bundler, install the permissionless.js SDK.



permissionless.js
Build with ERC-4337 smart accounts, bundlers, paymasters, and user operations
npm
pnpm
yarn
npm install permissionless
permissionless.js is a TypeScript library built on viem for building with ERC-4337 smart accounts, bundlers, paymasters, and user operations. The core focuses are avoiding provider lock-in, having no dependencies, maximum viem compatibility, and a small bundle size. permissionless.js also provides high-level support for the major ERC-4337 smart accounts, including Safe, Kernel, Biconomy, SimpleAccount, TrustWallet and LightAccount.
Get started
GitHub
Overview

// Import the required modules.
import { createSmartAccountClient } from "permissionless"
import { sepolia } from "viem/chains"
import { http } from "viem"
 
// Create the required clients.
const bundlerClient = createSmartAccountClient({
    chain: sepolia,
    bundlerTransport: http(bundlerUrl), // Use any bundler url
})
 
// Consume bundler, paymaster, and smart account actions!
const opReceipt = await bundlerClient.getUserOperationReceipt({
    hash: userOpHash
})
 
// Build with strict TypeScript types
opReceipt!.

actualGasUsed
 
Features
High-level smart account support: We support a high-level API for deploying and managing smart accounts, including some of the most popular implementations (Safe, Kernel, Biconomy, TrustWallet, etc.)
Bundler support: We support all bundler actions following ERC-4337.
Gas sponsorship: We support paymaster actions to allow you to easily sponsor gas fees.
User Operation utility functions: We provide many low-level utility functions useful for dealing with User Operations.
Modular and extensible: We allow you to easily create and plug in your own smart account systems, bundlers, paymasters, and signers.
Built on & for viem: permissionless.js is designed to be a thin wrapper around viem, maintaining the same style and overall feel viem provides.
and a lot more...




example.ts
+ import { createPimlicoClient } from "permissionless/clients/pimlico";
import { parseEther } from "viem";
import { bundlerClient, smartAccount } from "./config.ts" // The config.ts is the same as in the previous example.

- const maxFeePerGas = 1n;
- const maxPriorityFeePerGas = 1n;

+ const pimlicoClient = createPimlicoClient({
+   transport: http("https://api.pimlico.io/v2/11155111/rpc"), // You can get the API Key from the Pimlico dashboard.
+ });
+
+ const { fast: fee } = await pimlicoClient.getUserOperationGasPrice();

const userOperationHash = await bundlerClient.sendUserOperation({
  account: smartAccount,
  calls: [
    {
      to: "0x1234567890123456789012345678901234567890",
      value: parseEther("1")
    }
  ],
-  maxFeePerGas,
-  maxPriorityFeePerGas
+  ...fee
});
Wait for the transaction receipt
After submitting the user operation, it's crucial to wait for the receipt to ensure that it has been successfully included in the blockchain. Use the waitForUserOperationReceipt method provided by the bundler client.

example.ts
import { createPimlicoClient } from "permissionless/clients/pimlico";
import { bundlerClient, smartAccount } from "./config.ts" // The config.ts is the same as in the previous example.

const pimlicoClient = createPimlicoClient({
  transport: http("https://api.pimlico.io/v2/11155111/rpc"), // You can get the API Key from the Pimlico dashboard.
});

const { fast: fee } = await pimlicoClient.getUserOperationGasPrice();

const userOperationHash = await bundlerClient.sendUserOperation({
  account: smartAccount,
  calls: [
    {
      to: "0x1234567890123456789012345678901234567890",
      value: parseEther("1")
    }
  ],
  ...fee
});

+ const { receipt } = await bundlerClient.waitForUserOperationReceipt({
+   hash: userOperationHash
+ });
+
+ console.log(receipt.transactionHash);




Send a gasless transaction
MetaMask Smart Accounts support gas sponsorship, which simplifies onboarding by abstracting gas fees away from end users. You can use any paymaster service provider, such as Pimlico or ZeroDev, or plug in your own custom paymaster.

Prerequisites
Install and set up the Delegation Toolkit.
Create a MetaMask smart account.
Send a gasless transaction
The following example demonstrates how to use Viem's Paymaster Client to send gasless transactions. You can provide the paymaster client using the paymaster property in the sendUserOperation method, or in the Bundler Client.

In this example, the paymaster client is passed to the sendUserOperation method.

example.ts
config.ts

import { bundlerClient, smartAccount, paymasterClient } from "./config.ts";
import { parseEther } from "viem";

// Appropriate fee per gas must be determined for the specific bundler being used.
const maxFeePerGas = 1n;
const maxPriorityFeePerGas = 1n;

const userOperationHash = await bundlerClient.sendUserOperation({
  account: smartAccount,
  calls: [
    {
      to: "0x1234567890123456789012345678901234567890",
      value: parseEther("0.001")
    }
  ],
  maxFeePerGas,
  maxPriorityFeePerGas,
  paymaster: paymasterClient,
});



import { createPublicClient, createPaymasterClient, http } from "viem";
import { createBundlerClient } from "viem/account-abstraction";
import { sepolia as chain } from "viem/chains";
import { generatePrivateKey, privateKeyToAccount } from "viem/accounts";
import { 
  Implementation, 
  toMetaMaskSmartAccount,
} from "@metamask/delegation-toolkit";


const publicClient = createPublicClient({
  chain,
  transport: http()
});

const privateKey = generatePrivateKey(); 
const account = privateKeyToAccount(privateKey);

export const smartAccount = await toMetaMaskSmartAccount({
  client: publicClient,
  implementation: Implementation.Hybrid,
  deployParams: [account.address, [], [], []],
  deploySalt: "0x",
  signer: { account },
});

export const bundlerClient = createBundlerClient({
  client: publicClient,
  transport: http("https://api.pimlico.io/v2/11155111/rpc")
});

export const paymasterClient = createPaymasterClient({
  // You can use the paymaster of your choice
  transport: http("https://api.pimlico.io/v2/11155111/rpc")
});




Generate a multisig signature
The MetaMask Delegation Toolkit supports Multisig smart accounts, allowing you to add multiple externally owned accounts (EOA) signers with a configurable execution threshold. When the threshold is greater than 1, you can collect signatures from the required signers and use the aggregateSignature function to combine them into a single aggregated signature.

Prerequisites
Install and set up the Delegation Toolkit.
Create a Multisig smart account.
Generate a multisig signature
The following example configures a Multisig smart account with two different signers: Alice and Bob. The account has a threshold of 2, meaning that signatures from both parties are required for any execution.

example.ts
config.ts


import { 
  bundlerClient, 
  aliceSmartAccount, 
  bobSmartAccount,
  aliceAccount,
  bobAccount,
} from "./config.ts";
import { aggregateSignature } from "@metamask/delegation-toolkit";

const userOperation = await bundlerClient.prepareUserOperation({
  account: aliceSmartAccount,
  calls: [
    {
      target: zeroAddress,
      value: 0n,
      data: "0x",
    }
  ]
});

const aliceSignature = await aliceSmartAccount.signUserOperation(userOperation);
const bobSignature = await bobSmartAccount.signUserOperation(userOperation);

const aggregatedSignature = aggregateSignature({
  signatures: [{
    signer: aliceAccount.address,
    signature: aliceSignature,
    type: "ECDSA",
  }, {
    signer: bobAccount.address,
    signature: bobSignature,
    type: "ECDSA",
  }],
});



import { createPublicClient, http } from "viem";
import { generatePrivateKey, privateKeyToAccount } from "viem/accounts";
import { createBundlerClient } from "viem/account-abstraction";
import { sepolia as chain } from "viem/chains";
import { 
  Implementation, 
  toMetaMaskSmartAccount,
} from "@metamask/delegation-toolkit";

const publicClient = createPublicClient({
  chain,
  transport: http()
});

const alicePrivateKey = generatePrivateKey(); 
export const aliceAccount = privateKeyToAccount(alicePrivateKey);

const bobPrivateKey = generatePrivateKey();
export const bobAccount = privateKeyToAccount(bobPrivateKey)

const signers = [ aliceAccount.address, bobAccount.address ];
const threshold = 2n

export const aliceSmartAccount = await toMetaMaskSmartAccount({
  client: publicClient,
  implementation: Implementation.MultiSig,
  deployParams: [signers, threshold],
  deploySalt: "0x",
  signer: [ { account: aliceAccount } ],
});

export const bobSmartAccount = await toMetaMaskSmartAccount({
  client: publicClient,
  implementation: Implementation.MultiSig,
  deployParams: [signers, threshold],
  deploySalt: "0x",
  signer: [ { account: bobAccount } ],
});

export const bundlerClient = createBundlerClient({
  client: publicClient,
  transport: http("https://public.pimlico.io/v2/rpc")
});




Perform executions on a smart account's behalf
Delegation is the ability for a MetaMask smart account to grant permission to another account to perform executions on its behalf.

In this guide, you'll create a delegator account (Alice) and a delegate account (Bob), and grant Bob permission to perform executions on Alice's behalf. You'll complete the delegation lifecycle (create, sign, and redeem a delegation).

Prerequisites
Install and set up the Delegation Toolkit.

Steps
1. Create a Public Client
Create a Viem Public Client using Viem's createPublicClient function. You will configure Alice's account (the delegator) and the Bundler Client with the Public Client, which you can use to query the signer's account state and interact with smart contracts.

import { createPublicClient, http } from "viem"
import { sepolia as chain } from "viem/chains"

const publicClient = createPublicClient({
  chain,
  transport: http(),
})
2. Create a Bundler Client
Create a Viem Bundler Client using Viem's createBundlerClient function. You can use the bundler service to estimate gas for user operations and submit transactions to the network.

import { createBundlerClient } from "viem/account-abstraction"

const bundlerClient = createBundlerClient({
  client: publicClient,
  transport: http("https://your-bundler-rpc.com"),
})
3. Create a delegator account
Create an account to represent Alice, the delegator who will create a delegation. The delegator must be a MetaMask smart account; use the toolkit's toMetaMaskSmartAccount method to create the delegator account.

A Hybrid smart account is a flexible smart account implementation that supports both an externally owned account (EOA) owner and any number of P256 (passkey) signers. This examples configures a Hybrid smart account with an Account signer:

import { Implementation, toMetaMaskSmartAccount } from "@metamask/delegation-toolkit"
import { privateKeyToAccount } from "viem/accounts"

const delegatorAccount = privateKeyToAccount("0x...")

const delegatorSmartAccount = await toMetaMaskSmartAccount({
  client: publicClient,
  implementation: Implementation.Hybrid,
  deployParams: [delegatorAccount.address, [], [], []],
  deploySalt: "0x",
  signer: { account: delegatorAccount },
})
note
See how to configure other smart account types.

4. Create a delegate account
Create an account to represent Bob, the delegate who will receive the delegation. The delegate can be a smart account or an externally owned account (EOA):

Smart account
EOA


import { Implementation, toMetaMaskSmartAccount } from "@metamask/delegation-toolkit"
import { privateKeyToAccount } from "viem/accounts"

const delegateAccount = privateKeyToAccount("0x...")

const delegateSmartAccount = await toMetaMaskSmartAccount({
  client: publicClient,
  implementation: Implementation.Hybrid, // Hybrid smart account
  deployParams: [delegateAccount.address, [], [], []],
  deploySalt: "0x",
  signer: { account: delegateAccount },
})




import { privateKeyToAccount } from "viem/accounts";
import { sepolia as chain } from "viem/chains";
import { createWalletClient, http } from "viem";

const delegateAccount = privateKeyToAccount("0x...");

export const delegateWalletClient = createWalletClient({
  account: delegateAccount,
  chain,
  transport: http(),
})




5. Create a delegation
Create a root delegation from Alice to Bob. With a root delegation, Alice is delegating her own authority away, as opposed to redelegating permissions she received from a previous delegation.

Use the toolkit's createDelegation method to create a root delegation. When creating delegation, you need to configure the scope of the delegation to define the initial authority.

This example uses the erc20TransferAmount scope, allowing Alice to delegate to Bob the ability to spend her USDC, with a specified limit on the total amount.

Important
Before creating a delegation, ensure that the delegator account (in this example, Alice's account) has been deployed. If the account is not deployed, redeeming the delegation will fail.

import { createDelegation } from "@metamask/delegation-toolkit"
import { parseUnits } from "viem"

// USDC address on Ethereum Sepolia.
const tokenAddress = "0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238"

const delegation = createDelegation({
  to: delegateSmartAccount.address, // This example uses a delegate smart account
  from: delegatorSmartAccount.address,
  environment: delegatorSmartAccount.environment
  scope: {
    type: "erc20TransferAmount",
    tokenAddress,
    // 10 USDC 
    maxAmount: parseUnits("10", 6),
  },
})
6. Sign the delegation
Sign the delegation with Alice's account, using the signDelegation method from MetaMaskSmartAccount. Alternatively, you can use the toolkit's signDelegation utility method. Bob will later use the signed delegation to perform actions on Alice's behalf.

const signature = await delegatorSmartAccount.signDelegation({
  delegation,
})

const signedDelegation = {
  ...delegation,
  signature,
}
7. Redeem the delegation
Bob can now redeem the delegation. The redeem transaction is sent to the DelegationManager contract, which validates the delegation and executes actions on Alice's behalf.

To prepare the calldata for the redeem transaction, use the redeemDelegations method from DelegationManager. Since Bob is redeeming a single delegation chain, use the SingleDefault execution mode.

Bob can redeem the delegation by submitting a user operation if his account is a smart account, or a regular transaction if his account is an EOA. In this example, Bob transfers 1 USDC from Alice’s account to his own.

Redeem with a smart account
Redeem with an EOA
config.ts



import { createExecution, ExecutionMode } from "@metamask/delegation-toolkit"
import { DelegationManager } from "@metamask/delegation-toolkit/contracts"
import { zeroAddress } from "viem"
import { callData } from "./config.ts"

const delegations = [signedDelegation]

// USDC address on Ethereum Sepolia.
const tokenAddress = "0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238"

const executions = createExecution({ target: tokenAddress, callData })

const redeemDelegationCalldata = DelegationManager.encode.redeemDelegations({
  delegations: [delegations],
  modes: [ExecutionMode.SingleDefault],
  executions: [executions],
})

const userOperationHash = await bundlerClient.sendUserOperation({
  account: delegateSmartAccount,
  calls: [
    {
      to: delegateSmartAccount.address,
      data: redeemDelegationCalldata,
    },
  ],
  maxFeePerGas: 1n,
  maxPriorityFeePerGas: 1n,
})




import { createExecution, getDeleGatorEnvironment, ExecutionMode } from "@metamask/delegation-toolkit"
import { DelegationManager } from "@metamask/delegation-toolkit/contracts"
import { zeroAddress } from "viem"
import { callData } from "./config.ts"

const delegations = [signedDelegation]

// USDC address on Ethereum Sepolia.
const tokenAddress = "0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238"

const executions = createExecution({ target: tokenAddress, callData })

const redeemDelegationCalldata = DelegationManager.encode.redeemDelegations({
  delegations: [delegations],
  modes: [ExecutionMode.SingleDefault],
  executions: [executions]
});

const transactionHash = await delegateWalletClient.sendTransaction({
  to: getDeleGatorEnvironment(chain.id).DelegationManager,
  data: redeemDelegationCalldata,
  chain,
})





import { encodeFunctionData, erc20Abi, parseUnits } from "viem"

// calldata to transfer 1 USDC to delegate address.
export const callData = encodeFunctionData({
  abi: erc20Abi,
  args: [ delegateSmartAccount.address, parseUnits("1", 6) ],
  functionName: 'transfer',
})





